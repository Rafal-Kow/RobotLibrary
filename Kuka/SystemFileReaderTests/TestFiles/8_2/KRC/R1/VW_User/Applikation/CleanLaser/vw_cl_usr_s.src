&ACCESS  RV
&PARAM DISKPATH = VW_User/Applikation/CleanLaser
&PARAM TPVW_VERSION = 8.3.0
&REL 200
DEF vw_cl_usr_s( )
; 
;*-----------------------------------------------------*
;*Technologiepaket CleanLaser                          *
;*                                                     *
;*Konzernstandard                                      *
;*Bearbeiter: W. Lehmeier I/PG-C61                     *
;*                                                     *
;* Erstellt am:                                        *
;* 2015.06.17 LE                                       *
;*                                                     *
;* Änderung:                                           *
;* 2015.12.02 OL/LZ O_CL_C_Ein=2669 ersetzt gem. E/A   *
;*                                                     *
;*------------------------------------------------------
; 
END
;
;FOLD INIT CleanLaser 
GLOBAL DEF CL_INIT( )
INT i
;
;FOLD Version Techpaket
Tech_CleanLaser.Name[]="KS24.01.003_151202"
;ENDFOLD
;
;FOLD Vorbesetzung Meldungsausgabe
FOR i = 1 TO 100
  n_CLS_Handle[i]=-1
  n_CLR_Handle[i]=-1
ENDFOR
;ENDFOLD
;
;FOLD Vorbesetzung Fehlerflag
FOR i=1 TO 100
  L_UEBW_FLAG[i]=FALSE
ENDFOR
;ENDFOLD
;
END
;ENDFOLD
;
;-----------------------------------------------------------
;FOLD SAW CleanLaser 
GLOBAL DEF CL_SAW( )
INT i
;
;
END
;ENDFOLD
;
;-----------------------------------------------------------
;FOLD RESET CleanLaser 
GLOBAL DEF CL_RESET( )
INT i
;
;
END
;ENDFOLD
;
;-----------------------------------------------------------
;FOLD CANCEL CleanLaser 
GLOBAL DEF CL_CANCEL( )
INT i
;
;
END
;ENDFOLD
;
;-----------------------------------------------------------
;FOLD LOOP CleanLaser  
GLOBAL DEF CL_LOOP( )
INT i
;
;Ausgabe Statusmeldungen an BMS
;
;Quitt. Warnung
$OUT[O_CL_Q_Warn]=$IN[I_R_Quit_St] OR $IN[I_R_Quit_Wei]
;Prozess aktiv
$OUT[O_CL_P_aktiv]=$OUT[O_CL_L_Ein]
;Warnung
$OUT[O_CL_Warnung]=$IN[I_CL_Warn_L]
;Stoerung Laser
$OUT[O_CL_Stoe_L]=$IN[I_CL_Stoe_L]
;Sammelstoerung
$OUT[O_CL_Sammel]=$OUT[O_R_Auto] AND $COULD_START_MOTION AND $IN[I_CL_Stoe_L]
;
;CleanLaser Controller ein/aus
IF $IN[I_CL_C_Ein] THEN
  $OUT[O_CL_C_Ein]=TRUE
ELSE
  $OUT[O_CL_C_Ein]=FALSE
ENDIF
;
;Clean-Laser runter bzw. hochfahren
IF NOT $OUT[O_R_PFO] AND $OUT[O_R_PERI_RDY] THEN
  Timer1_CL=$ROB_TIMER ;Timerout triggern
ENDIF
;
IF (($ROB_TIMER-Timer1_MS1)>3000) OR NOT $OUT[O_R_PERI_RDY] THEN
  $OUT[O_CL_L_hoch]=FALSE ;Laser herunterfahren
  $OUT[O_CL_L_Ein]=FALSE ;Laserstrahl aus
ELSE
  $OUT[O_CL_L_hoch]=TRUE ;Laser hochfahren
ENDIF
;
;Clean-Laser-Naht-Ueberwachung
IF $FLAG[F_CL_Ueb_Ein] AND $OUT[O_CL_L_Ein] THEN
  IF NOT $OUT[O_R_PERI_RDY] OR NOT $OUT[O_R_Proz_akt] OR NOT $FLAG[F_FB_PSPS] THEN
    $OUT[O_CL_L_Ein]=FALSE ;Laserstrahl aus
    IF (($B_OUT[17]>0) AND ($B_OUT[17]<=100)) THEN
      L_UEBW_FLAG[$B_OUT[17]]=TRUE ;Laser-Naht fehlerhaft
    ELSE
      CleanLaser_Msg(2,#NotifyMsg)  
    ENDIF
  ENDIF
ENDIF
;
;Pruefung Lasernaehte i.O.
IF $FLAG[F_L_Naht_Pru] THEN
  $FLAG[F_L_Naht_IO]=FALSE
  $FLAG[F_L_Naht_NIO]=FALSE
  FOR i=1 TO 100
    IF L_UEBW_FLAG[i] THEN
      $FLAG[F_L_Naht_NIO]=TRUE
    ENDIF
  ENDFOR
  IF NOT $FLAG[F_L_Naht_NIO] THEN
    $FLAG[F_L_Naht_IO]=TRUE
  ENDIF 
  $FLAG[F_L_Naht_Pru]=FALSE  
ENDIF
;
;Fehlerflag ruecksetzen
IF $OUT[O_R_PFO] AND $ROB_STOPPED AND (($mode_op==#T1) OR ($mode_op==#T2)) THEN
  FOR i=1 TO 100
    L_UEBW_FLAG[i]=FALSE
  ENDFOR
ENDIF
;
END
;ENDFOLD
;
;-----------------------------------------------------------
;FOLD Lebensbit CL
DEF L_Bit_CL(CLNr :IN)
;Setzen / Rueksetzen Lebensbit Roboter
INT CLNr
BOOL LBitCL, LBitFault
INT RobTimer
BOOL ErrLBit, bRet
ErrLBit = FALSE
LBitFault=FALSE
;Setzen - Rucksetzen  des Lebensbit an Zangensteuerung
$OUT[LBitToCL[CLNr]] = NOT $IN[LBitFromCL[CLNr]]
RobTimer = $ROB_TIMER	
IF $IN[LBitFromCL[CLNr]] <> LBitState[CLNr] THEN
  LBitTimeCnt[CLNr] = RobTimer
ENDIF
IF (RobTimer - LBitTimeCnt[CLNr]) > 5000 THEN
  ErrLBit = TRUE
  ErrCLNr = CLNr
  CL_LBitFeh[CLNr]=TRUE
ENDIF
LBitState[CLNr] = $IN[LBitFromCL[CLNr]]
IF ErrLBit THEN
  CleanLaser_Msg(1,#StateMsg, ErrCLNr)
ELSE
  IF n_CLS_Handle[1]>-1 THEN
    bRet=Clear_KrlMsg(n_CLS_Handle[1])
    n_CLS_Handle[1]=-1
    ErrCLNr = -1
  ENDIF
  CL_LBitFeh[CLNr]=FALSE
ENDIF
END
;ENDFOLD
;
;-----------------------------------------------------------
;FOLD CL_Meldungen
DEF CleanLaser_Msg(msg_nr :IN, MsgTyp :IN, CLNr :IN)
INT msg_nr, CLNr, Answer
DECL CLS_MsgType MsgTyp
DECL KrlMsg_T USER_MSG
DECL KrlMsgPar_T Par[3]
DECL KrlMsgOpt_T Opt
;
USER_MSG = { Modul[] "CL_S_Msg", Nr -1, Msg_txt[] " "}
Opt = { VL_Stop FALSE, Clear_P_Reset TRUE, Log_To_DB TRUE }
Par[1] = { Par_type #Value, Par_txt[] " " }
;
IF Varstate("CLNr")==#initialized then
  SWITCH CLNr
    CASE 1
      Par[1] = { Par_type #Value, Par_int 1 }
    CASE 2
      Par[1] = { Par_type #Value, Par_int 2 }
    CASE 3
      Par[1] = { Par_type #Value, Par_int 3 }
    CASE 4
      Par[1] = { Par_type #Value, Par_int 4 }
    CASE 5
      Par[1] = { Par_type #Value, Par_int 5 }
    CASE 6
      Par[1] = { Par_type #Value, Par_int 6 }
    DEFAULT
      Par[1] = { Par_type #Value, Par_txt[] " " }
  ENDSWITCH
ELSE
  Par[1] = { Par_type #Value, Par_txt[] " " }
ENDIF
;
IF ((n_CLS_Handle[msg_nr]<0) OR (MsgTyp==#NotifyMsg) OR (MsgTyp==#QuitMsg)) THEN
  USER_MSG.Nr = msg_nr
  SWITCH msg_nr
    CASE 1
	   USER_MSG.MSG_TXT[]="keine Antwort auf Lebensbit"
    CASE 2
	   USER_MSG.MSG_TXT[]="Binaerausgabe 17 nicht programmiert"
    CASE 3
	   USER_MSG.MSG_TXT[]=" "
    CASE 4
	   USER_MSG.MSG_TXT[]=" "
    DEFAULT
	   USER_MSG.MSG_TXT[]="unbekannte Meldung"
  ENDSWITCH
  SWITCH MsgTyp
    CASE #StateMsg
      n_CLS_Handle[msg_nr] = Set_KrlMsg (#State, USER_MSG, Par[], Opt) ;Ausgabe Statusmeldung
    CASE #QuitMsg
      n_CLS_Handle[msg_nr] = Set_KrlMsg (#Quit, USER_MSG, Par[], Opt) ;Ausgabe Quittierungsmeldung
    CASE #NotifyMsg
      n_CLS_Handle[msg_nr] = Set_KrlMsg (#Notify, USER_MSG, Par[], Opt) ;Ausgabe Hinweismeldung
    DEFAULT
      n_CLS_Handle[msg_nr] = Set_KrlMsg (#Quit, USER_MSG, Par[], Opt) ;Ausgabe Quittierungsmeldung
  ENDSWITCH
ENDIF
END
;
;ENDFOLD (CL Meldungen)
