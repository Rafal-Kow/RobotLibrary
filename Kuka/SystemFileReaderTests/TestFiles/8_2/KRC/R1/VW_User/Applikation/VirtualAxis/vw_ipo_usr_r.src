&ACCESS  RV
&PARAM DISKPATH = VW_User/Applikation/VirtualAxis
&PARAM TPVW_VERSION = 8.3.0
&REL 200
DEF VW_Ipo_USR_R( )
; 
;*--------------------------------------------------------*
;*Technologiepaket Totzeitermittlung (Ipo-Taktermittlung) *
;*                 SynchroMove                            *
;*                                                        *
;*Konzernstandard                                         *
;*Bearbeiter: Chr. Eisenknappl I/PG-C61                   *
;*                                                        *
;* Erstellt am:                                           *
;* 10.12.2014 CE                                          *
;*                                                        *
;*--------------------------------------------------------*
;
END
;
;FOLD Ipo Interface
GLOBAL DEF Ipo_Interfac(USER_CMD:IN,CMD_SEL:IN,PAR1:IN,PAR2:IN,PAR3:IN,PAR4:IN,PAR5:IN,PAR6:IN)
DECL VW_USER_CMD USER_CMD
INT  CMD_SEL,PAR1,PAR2,PAR3,PAR4,PAR5,PAR6
INT I
E6AXIS GunPosAct, GunPosOpen, GunPosClose
;
;-----------------------------------------------------------
;
SWITCH USER_CMD
;
;-----------------------------------------------------------
;
  CASE #USR_INIT
    ;FOLD Init
    ;
    ;
    ;ENDFOLD (Init)
;
;-----------------------------------------------------------
;
  CASE #USR_ADV
    ;FOLD Advance
    ;
    ;
    ;ENDFOLD (Advance)
;
;-----------------------------------------------------------
;
  CASE #USR_TRIG
    ;FOLD Trig
    ;
    ;
    ;ENDFOLD (Trig)
;
;-----------------------------------------------------------
;
  CASE #USR_MAIN
    ;FOLD Main
    ;
    ;
    ;ENDFOLD (Main)
;
;-----------------------------------------------------------
;
  CASE #USR_MAKRO
    ;FOLD Makro
    ;
    EaxNum=-1
    MerkOvPro=-1
    ;
    GunPosAct=$axis_act
    GunPosOpen=$axis_act
    GunPosClose=$axis_act
    ;
    ;SoftPLC Bootfile Version pruefen
    VerBootfile=$softplcint[22]
    WHILE VerBootfile<420
      Ipo_Msg(7,#QuitMsg) ;bootfile version > 4.2.0 erforderlich
      HALT
    ENDWHILE   
    ;
    ;Zuordnung Roboterachse
    REPEAT
      DiNum=PAR1
      EaxNum=$softplcint[DiNum]-6
      IF (($softplcint[DiNum]>6) AND ($softplcint[DiNum]<13)) THEN
        EaxNum = $softplcint[DiNum]-6
      ELSE
        Ipo_Msg(6,#NotifyMsg)
        HALT
      ENDIF
    UNTIL EaxNum>0 
    ;
    IF (DiNum==1) OR (DiNum==2) OR (DiNum==3) THEN
      OffsetPos_p=20
      OffsetPos_n=30
      PosClose=0
    ELSE
      OffsetPos_p=20  
      OffsetPos_n=10
      PosClose=0
    ENDIF
    ;
    SWITCH EaxNum
      CASE 0
        HALT ;keine Zuordnung - Roboterachse
      CASE 1
        GunPosOpen.E1=$softp_end[7]-OffsetPos_p
        GunPosClose.E1=$softn_end[7]+OffsetPos_n
        PosClose=$softn_end[7]+OffsetPos_n
      CASE 2
        GunPosOpen.E2=$softp_end[8]-OffsetPos_p
        GunPosClose.E2=$softn_end[8]+OffsetPos_n
        PosClose=$softn_end[8]+OffsetPos_n
      CASE 3
        GunPosOpen.E3=$softp_end[9]-OffsetPos_p
        GunPosClose.E3=$softn_end[9]+OffsetPos_n
        PosClose=$softn_end[9]+OffsetPos_n
      CASE 4
        GunPosOpen.E4=$softp_end[10]-OffsetPos_p
        GunPosClose.E4=$softn_end[10]+OffsetPos_n
        PosClose=$softn_end[10]+OffsetPos_n
      CASE 5
        GunPosOpen.E5=$softp_end[11]-OffsetPos_p
        GunPosClose.E5=$softn_end[11]+OffsetPos_n
        PosClose=$softn_end[11]+OffsetPos_n
      CASE 6
        GunPosOpen.E6=$softp_end[12]-OffsetPos_p
        GunPosClose.E6=$softn_end[12]+OffsetPos_n
        PosClose=$softn_end[12]+OffsetPos_n
      DEFAULT
      HALT ;ungueltige Zuordnung Antriebsschnittstelle --> Zusatzachse
    ENDSWITCH
    ;
    IF $MODE_OP==#T1 THEN
      Ipo_Msg(3,#NotifyMsg)
      REPEAT
        WAIT SEC 0.1
      UNTIL ($mode_op<>#t1)  
    ENDIF
    ;
    IF $MODE_OP==#EX THEN
      IF $OV_PRO<>100 THEN
        MerkOvPro=$OV_PRO
        $OV_PRO=100
      ENDIF  
    ELSE  
      IF $OV_PRO<>100 THEN
        Ipo_Msg(4,#NotifyMsg)
        REPEAT
          WAIT SEC 0.1
        UNTIL ($ov_pro==100)
      ENDIF
    ENDIF
    ;
    FOR co=1 TO 20
      IpoVerteilung[co]=0
    ENDFOR
    $softplcint[20]=-1*DiNum
    WAIT SEC 0.5
    BAS (#INITMOV,0)
    PTP $AXIS_ACT
    PTP GunPosClose
    WAIT SEC 0.3
    ActPos=GetActPos(DiNum)
    IF ABS(PosClose-ActPos)>5 THEN
      Ipo_Msg(5,#QuitMsg,EaxNum)
      WHILE (ABS(PosClose-ActPos)>5)
        WAIT SEC 0.2
      ENDWHILE  
    ENDIF
    ;
    ;Aufzeichnung starten
    $softplcint[20]=DiNum
    ;
    FOR co=1 TO 10
      PTP GunPosOpen
      ;WAIT FOR NOT ($IN[I_SZ1_F_Ziel] OR $IN[I_sz2_tpos_g])
      PTP GunPosClose C_PTP
    ENDFOR
    ;Aufzeichnung beenden
    $softplcint[20]=-10
    PTP GunPosAct
    WAIT SEC 0.2
    ;Ueberwachung aktivieren  
    $softplcint[20]=0
    WAIT SEC 0.1
    ;
    ;Schreiben der neuen Totzeiten
    TotzeitAlt=SysBusDelay[EaxNum]
    TotzeitNeu=$softplcint[31]
    SysBusDelay[EaxNum]=TotzeitNeu
    $softplcint[EaxNum+7]=TotzeitNeu
    ;Schreiben der Verteilung
    FOR co=1 TO 20
      IpoVerteilung[co]=$softplcint[99+co]
    ENDFOR
    TraceTime.YEAR=$Date.YEAR
    TraceTime.MONTH=$Date.MONTH
    TraceTime.DAY=$Date.DAY
    TraceTime.HOUR=$Date.HOUR
    TraceTime.MIN=$Date.MIN
    TraceTime.SEC=$Date.SEC
    RobSn=$KR_SERIALNO
    TraceLength=$softplcint[34]
    IF $mode_op<>#EX THEN
      Ipo_Msg(1,#NotifyMsg,DiNum)
      Ipo_Msg(2,#NotifyMsg,DiNum)
    ENDIF
    ;
    IF MerkOvPro>0 THEN
      $OV_PRO=MerkOvPro
    ENDIF
    ;
    ;ENDFOLD (Makro)
;
;-----------------------------------------------------------
  DEFAULT
;  
  ENDSWITCH
END
;
;ENDFOLD (Ipo Interface)
;
;-----------------------------------------------------------
DEFFCT REAL GetActPos(di:in)
INT di
REAL RetGunPos
REAL GunPos[7]
;
GunPos[1]=sig1_istpos
GunPos[2]=sig2_istpos
GunPos[3]=sig3_istpos
GunPos[4]=sig4_istpos
GunPos[5]=sig5_istpos
GunPos[6]=sig6_istpos
GunPos[7]=sig7_istpos  
;
RetGunPos=GunPos[di]/10
IF $IN[Sign[di]] THEN
  RetGunPos=RetGunPos*(-1)
ENDIF
;    
RETURN(RetGunPos)
ENDFCT
;
;-----------------------------------------------------------
;FOLD Ipo Meldungen
DEF Ipo_Msg(msg_nr :IN, MsgTyp :IN, Param :IN )
INT msg_nr, Param
DECL IPOR_MsgType MsgTyp
DECL KrlMsg_T USER_MSG
DECL KrlMsgPar_T Par[3]
DECL KrlMsgOpt_T Opt
DECL State_T st_ausg
INT offset, Answer
;
USER_MSG = { Modul[] "vw_ipo_usr_r", Nr -1, Msg_txt[] " "}
Opt = { VL_Stop False, Clear_P_Reset False, Log_To_DB TRUE }
;
IF Varstate("Param")==#initialized then
  SWITCH Param
    CASE 1
      Par[1] = { Par_type #Value, Par_int 1 }
    CASE 2
      Par[1] = { Par_type #Value, Par_int 2 }
    CASE 3
      Par[1] = { Par_type #Value, Par_int 3 }
    CASE 4
      Par[1] = { Par_type #Value, Par_int 4 }
    CASE 5
      Par[1] = { Par_type #Value, Par_int 5 }
    CASE 6
      Par[1] = { Par_type #Value, Par_int 6 }
    DEFAULT
      Par[1] = { Par_type #Value, Par_txt[] " " }
  ENDSWITCH
ELSE
  Par[1] = { Par_type #Value, Par_txt[] " " }
ENDIF
;
IF ((n_IPOR_Handle[msg_nr]<0) OR (MsgTyp==#NotifyMsg) OR (MsgTyp==#QuitMsg)) THEN
  USER_MSG.Nr = msg_nr
  SWITCH msg_nr
    CASE 1
      OFFSET=0
      SWRITE(USER_MSG.MSG_TXT[],ST_AUSG,OFFSET,"Totzeit Achse%d vor Testlauf= %d  *12ms",(EaxNum+6), TotzeitAlt)
    CASE 2
      OFFSET=0
      SWRITE(user_msg.msg_TXT[],ST_AUSG,OFFSET,"Totzeit Achse%d nach Testlauf= %d *12ms ",(EaxNum+6), TotzeitNeu)
    CASE 3
		USER_MSG.MSG_TXT[]="falsche Betriebsart - T2 oder EXT erforderlich"
    CASE 4
		USER_MSG.MSG_TXT[]="Override auf 100% erforderlich"
    CASE 5
		USER_MSG.MSG_TXT[]="Externe Achse%1 folgt nicht"
    CASE 6
		USER_MSG.MSG_TXT[]="keine Zuordnung Antriebsschnittstelle - Zusatzachse"
    CASE 7
		USER_MSG.MSG_TXT[]="Version bootfile wird nicht unterstuetzt"
    DEFAULT
      USER_MSG.MSG_TXT[]="unbekannte Meldung"
  ENDSWITCH
  ;
  SWITCH MsgTyp
    CASE #StateMsg
      n_IPOR_Handle[msg_nr] = Set_KrlMsg (#State, USER_MSG, Par[], Opt) ;Ausgabe Statusmeldung
    CASE #QuitMsg
      n_IPOR_Handle[msg_nr] = Set_KrlMsg (#Quit, USER_MSG, Par[], Opt) ;Ausgabe Quittierungsmeldung
      While ( Exists_KrlMsg(n_IPOR_Handle[msg_nr]) )  ;Warten bis der Anwender quittiert
        Wait Sec 0.1
      Endwhile
    CASE #NotifyMsg
      n_IPOR_Handle[msg_nr] = Set_KrlMsg (#Notify, USER_MSG, Par[], Opt) ;Ausgabe Hinweismeldung
    DEFAULT
      n_IPOR_Handle[msg_nr] = Set_KrlMsg (#Quit, USER_MSG, Par[], Opt) ;Ausgabe Quittierungsmeldung
  ENDSWITCH    
ENDIF
;
END 
;
;-----------------------------------------------------------
DEFFCT INT SetDlgMsg()
DECL KrlMsg_T Msg
DECL KrlMsgPar_T Par[3]
DECL KrlMsgOpt_T Opt
DECL KrlMsgDlgSK_T SK[7]
INT nHandle, nAnswer
;
Msg = { Modul[] "vw_ipo_usr_r", Nr 10, Msg_txt[] "Antriebsschnittstelle selektieren"}
SK[1]={ Sk_Type #VALUE, Sk_txt[] "1"}
SK[2]={ Sk_Type #VALUE, Sk_txt[] "2"}
SK[3]={ Sk_Type #VALUE, Sk_txt[] "3"}
SK[4]={ Sk_Type #VALUE, Sk_txt[] "4"}
SK[5]={ Sk_Type #VALUE, Sk_txt[] "5"}
SK[6]={ Sk_Type #VALUE, Sk_txt[] "6"}
SK[7]={ Sk_Type #VALUE, Sk_txt[] "7"}
;
Opt = { VL_Stop True, Clear_P_Reset True, Log_To_DB FALSE }
nHandle = Set_KrlDlg (Msg, Par[],SK[], Opt) ;Ausgabe Dialogmeldung
If (nHandle>0)Then
  While (Exists_KrlDlg(nHandle, nAnswer))
    Wait sec 0.1
  Endwhile  
Endif
Return(nAnswer)
;
ENDFCT
;
;ENDFOLD (Ipo Meldungen)

