&ACCESS  RV
&PARAM DISKPATH = VW_User/Applikation/FlowDrill
&PARAM TPVW_VERSION = 8.3.0
&REL 200
DEF vw_fds_usr_s( )
; 
;*-----------------------------------------------------*
;*Technologiepaket FlowDrill                           *
;*                                                     *
;*Konzernstandard                                      *
;*Bearbeiter: W. Lehmeier I/PG-C61                     *
;*                                                     *
;* Erstellt am:                                        *
;* 2015.02.20 LE                                       *
;*                                                     *
;*------------------------------------------------------
; 
END
;
;FOLD INIT FlowDrill 
GLOBAL DEF FDS_INIT( )
INT i
;
;FOLD Version Techpaket
Tech_FlowDrill.Name[]="KS24.01.002_150615"
;ENDFOLD
;
;FOLD Vorbesetzung Meldungsausgabe
FOR i = 1 TO 100
  n_FDSS_Handle[i]=-1
  n_FDSR_Handle[i]=-1
ENDFOR
;ENDFOLD
;
END
;ENDFOLD
;
;-----------------------------------------------------------
;FOLD SAW FlowDrill
GLOBAL DEF FDS_SAW( )
INT i
;
;
END
;ENDFOLD
;
;-----------------------------------------------------------
;FOLD RESET FlowDrill
GLOBAL DEF FDS_RESET( )
INT i
;
;
END
;ENDFOLD
;
;-----------------------------------------------------------
;FOLD CANCEL FlowDrill
GLOBAL DEF FDS_CANCEL( )
INT i
;
;
END
;ENDFOLD
;
;-----------------------------------------------------------
;FOLD LOOP FlowDrill 1
GLOBAL DEF FDS1_LOOP( )
;
;BA-Hand an FDS1 setzen
IF $OUT[O_R_Hand] AND NOT $COULD_START_MOTION THEN
  $OUT[O_FDS1_Hand]=TRUE
  $OUT[O_FDS1_Auto]=FALSE
ENDIF
;
;BA-AUTO an FDS 1 setzen
B_FDS1_Hilf = $OUT[O_FDS1_Start] OR $OUT[O_FDS1_Null]
IF (($OUT[O_R_Hand] AND $COULD_START_MOTION AND ($OUT[O_R_Proz_akt] OR B_FDS1_Hilf) AND $OUT[O_R_RK100]) OR $OUT[O_R_Auto]) THEN
  $OUT[O_FDS1_Hand]=FALSE
  $OUT[O_FDS1_Auto]=TRUE
ENDIF
;
;Vorwahl ohne Prozess
$OUT[O_FDS1_o_Pro]=$IN[I_FDS1_o_Pro] OR $FLAG[F_o_Prozess]    
;
;Ausgabe Statusmeldungen an BMS
;
;Schrauben n.i.O.
$OUT[O_FDS1_Pr_ni]=$OUT[O_R_Auto] AND $OUT[O_R_RK100] AND $IN[I_FDS1_Pr_ni]
;Vorwarnung Fuellstand
$OUT[O_FDS1_VW]=$OUT[O_R_Auto] AND $OUT[O_R_RK100] AND $IN[I_FDS1_Fuell]
;Wartungswarnung
$OUT[O_FDS1_Warn]=$OUT[O_R_Auto] AND $OUT[O_R_RK100] AND $IN[I_FDS1_Warn]
;Zange defekt
$OUT[O_FDS1_def]=$OUT[O_R_Auto] AND $OUT[O_R_RK100] AND $FLAG[F_FDS1_Z_def]
;Phasenueberwachung n.i.O.
$OUT[O_FDS1_Phase]=$OUT[O_R_Auto] AND $OUT[O_R_RK100] AND NOT $IN[I_FDS1_Phase]
;Startbereit fehlt
$OUT[O_FDS1_SBe_f]=$OUT[O_R_Auto] AND $OUT[O_R_RK100] AND NOT $IN[I_FDS1_StBer] AND NOT $IN[I_FDS1_Samme] AND $timer_flag[TimerNr_Ein]
;Betriebsbereit fehlt
$OUT[O_FDS1_Ber_f]=$OUT[O_R_Auto] AND $OUT[O_R_RK100] AND NOT $IN[I_FDS1_Berei] AND $timer_flag[TimerNr_Ein]
;Sammelstoerung
$OUT[O_FDS1_Samme]=$OUT[O_R_Auto] AND $OUT[O_R_RK100] AND (NOT $IN[I_FDS1_Samme] OR FDS_LBitFeh[1]) AND $timer_flag[TimerNr_Ein]
;	
;Lebensbit_Ueberwachung
L_Bit_FDS(1)    
;
END
;ENDFOLD
;
;-----------------------------------------------------------
;FOLD LOOP FlowDrill 2
GLOBAL DEF FDS2_LOOP( )
;
;BA-Hand an FDS2 setzen
IF $OUT[O_R_Hand] AND NOT $COULD_START_MOTION THEN
  $OUT[O_FDS2_Hand]=TRUE
  $OUT[O_FDS2_Auto]=FALSE
ENDIF
;
;BA-AUTO an FDS 1 setzen
B_FDS2_Hilf = $OUT[O_FDS2_Start] OR $OUT[O_FDS2_Null]
IF (($OUT[O_R_Hand] AND $COULD_START_MOTION AND ($OUT[O_R_Proz_akt] OR B_FDS2_Hilf) AND $OUT[O_R_RK100]) OR $OUT[O_R_Auto]) THEN
  $OUT[O_FDS2_Hand]=FALSE
  $OUT[O_FDS2_Auto]=TRUE
ENDIF
;
;Vorwahl ohne Prozess
$OUT[O_FDS2_o_Pro]=$IN[I_FDS2_o_Pro] OR $FLAG[F_o_Prozess]     
;
;Ausgabe Statusmeldungen an BMS
;
;Schrauben n.i.O.
$OUT[O_FDS2_Pr_ni]=$OUT[O_R_Auto] AND $OUT[O_R_RK100] AND $IN[I_FDS2_Pr_ni]
;Vorwarnung Fuellstand
$OUT[O_FDS2_VW]=$OUT[O_R_Auto] AND $OUT[O_R_RK100] AND $IN[I_FDS2_Fuell]
;Wartungswarnung
$OUT[O_FDS2_Warn]=$OUT[O_R_Auto] AND $OUT[O_R_RK100] AND $IN[I_FDS2_Warn]
;Zange defekt
$OUT[O_FDS2_def]=$OUT[O_R_Auto] AND $OUT[O_R_RK100] AND $FLAG[F_FDS2_Z_def]
;Phasenueberwachung n.i.O.
$OUT[O_FDS2_Phase]=$OUT[O_R_Auto] AND $OUT[O_R_RK100] AND NOT $IN[I_FDS2_Phase]
;Startbereit fehlt
$OUT[O_FDS2_SBe_f]=$OUT[O_R_Auto] AND $OUT[O_R_RK100] AND NOT $IN[I_FDS2_StBer] AND NOT $IN[I_FDS2_Samme] AND $timer_flag[TimerNr_Ein]
;Betriebsbereit fehlt
$OUT[O_FDS2_Ber_f]=$OUT[O_R_Auto] AND $OUT[O_R_RK100] AND NOT $IN[I_FDS2_Berei] AND $timer_flag[TimerNr_Ein]
;Sammelstoerung
$OUT[O_FDS2_Samme]=$OUT[O_R_Auto] AND $OUT[O_R_RK100] AND (NOT $IN[I_FDS2_Samme] OR FDS_LBitFeh[2]) AND $timer_flag[TimerNr_Ein]
;	
;Lebensbit_Ueberwachung
L_Bit_FDS(2)    
;
END
;ENDFOLD
;
;-----------------------------------------------------------
;FOLD Lebensbit_FDS
DEF L_Bit_FDS(FDSNr :IN)
;Setzen / Rueksetzen Lebensbit Roboter
INT FDSNr
BOOL LBitFDS, LBitFault
INT RobTimer
BOOL ErrLBit, bRet
ErrLBit = FALSE
LBitFault=FALSE
;Setzen - Rucksetzen  des Lebensbit an Zangensteuerung
$OUT[LBitToFDS[FDSNr]] = NOT $IN[LBitFromFDS[FDSNr]]
RobTimer = $ROB_TIMER	
IF $IN[LBitFromFDS[FDSNr]] <> LBitState[FDSNr] THEN
  LBitTimeCnt[FDSNr] = RobTimer
ENDIF
IF (RobTimer - LBitTimeCnt[FDSNr]) > 5000 THEN
  ErrLBit = TRUE
  ErrFDSNr = FDSNr
  FDS_LBitFeh[FDSNr]=TRUE
ENDIF
LBitState[FDSNr] = $IN[LBitFromFDS[FDSNr]]
IF ErrLBit THEN
  FlowDrill_Msg(1,#StateMsg, ErrFDSNr)
ELSE
  IF n_FDSS_Handle[1]>-1 THEN
    bRet=Clear_KrlMsg(n_FDSS_Handle[1])
    n_FDSS_Handle[1]=-1
    ErrFDSNr = -1
  ENDIF
  FDS_LBitFeh[FDSNr]=FALSE
ENDIF
;  
END
;ENDFOLD
;
;-----------------------------------------------------------
;FOLD FDS_Meldungen
DEF FlowDrill_Msg(msg_nr :IN, MsgTyp :IN, FDSNr :IN)
INT msg_nr, FDSNr, Answer
DECL FDSS_MsgType MsgTyp
DECL KrlMsg_T USER_MSG
DECL KrlMsgPar_T Par[3]
DECL KrlMsgOpt_T Opt
;
USER_MSG = { Modul[] "FlowDrillS_Msg", Nr -1, Msg_txt[] " "}
Opt = { VL_Stop FALSE, Clear_P_Reset TRUE, Log_To_DB TRUE }
Par[1] = { Par_type #Value, Par_txt[] " " }
;
IF Varstate("FDSNr")==#initialized then
  SWITCH FDSNr
    CASE 1
      Par[1] = { Par_type #Value, Par_int 1 }
    CASE 2
      Par[1] = { Par_type #Value, Par_int 2 }
    CASE 3
      Par[1] = { Par_type #Value, Par_int 3 }
    CASE 4
      Par[1] = { Par_type #Value, Par_int 4 }
    CASE 5
      Par[1] = { Par_type #Value, Par_int 5 }
    CASE 6
      Par[1] = { Par_type #Value, Par_int 6 }
    DEFAULT
      Par[1] = { Par_type #Value, Par_txt[] " " }
  ENDSWITCH
ELSE
  Par[1] = { Par_type #Value, Par_txt[] " " }
ENDIF
;
IF ((n_FDSS_Handle[msg_nr]<0) OR (MsgTyp==#NotifyMsg) OR (MsgTyp==#QuitMsg)) THEN
  USER_MSG.Nr = msg_nr
  SWITCH msg_nr
    CASE 1
	   USER_MSG.MSG_TXT[]="FDS%1 :keine Antwort auf Lebensbit"
    CASE 2
	   USER_MSG.MSG_TXT[]=" "
    CASE 3
	   USER_MSG.MSG_TXT[]=" "
    CASE 4
	   USER_MSG.MSG_TXT[]=" "
    DEFAULT
	   USER_MSG.MSG_TXT[]="unbekannte Meldung"
  ENDSWITCH
  SWITCH MsgTyp
    CASE #StateMsg
      n_FDSS_Handle[msg_nr] = Set_KrlMsg (#State, USER_MSG, Par[], Opt) ;Ausgabe Statusmeldung
    CASE #QuitMsg
      n_FDSS_Handle[msg_nr] = Set_KrlMsg (#Quit, USER_MSG, Par[], Opt) ;Ausgabe Quittierungsmeldung
       While ( Exists_KrlMsg(n_FDSS_Handle[msg_nr]) )  ;Warten bis der Anwender quittiert
        Wait Sec 0.1
      Endwhile
    CASE #NotifyMsg
      n_FDSS_Handle[msg_nr] = Set_KrlMsg (#Notify, USER_MSG, Par[], Opt) ;Ausgabe Hinweismeldung
    DEFAULT
      n_FDSS_Handle[msg_nr] = Set_KrlMsg (#Quit, USER_MSG, Par[], Opt) ;Ausgabe Quittierungsmeldung
  ENDSWITCH
ENDIF
END
;
;ENDFOLD (FDS_Meldungen)
