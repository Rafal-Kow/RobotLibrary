&ACCESS  R
&PARAM DISKPATH = System
&PARAM TPVW_VERSION =8.1.8
DEF VW_Safety()
END
;
;-----------------------------------------------------------
;
;FOLD ;%{H} %MKUKATPVW
GLOBAL DEF BrakeTestReq()
INT Ret,IntArray[5]
REAL RealArray[1]
BAS (#INITMOV,0 )
IF ($mode_op==#t1) THEN
  Ret = MD_CMD(brakeTestDevName[], "START_TEST", IntArray[], RealArray[])
  IF ($mode_op==#t1) THEN ; still T1 then return
    RETURN
  ENDIF
ENDIF
Ret = MD_CMD(brakeTestDevName[], "START_TEST", IntArray[], RealArray[])
IF (FlagNo_RunBrkTest>0) Then
  IF ( Ret <> 0) then
    ; Entweder (Ret == +1) - dann liegt keine Testanforderung vor - oder
    ; (Ret < 0) - dann wurde bereits eine Zustandsmeldung vom Treiber abgesetzt
    $Flag[FlagNo_RunBrkTest]=FALSE
  ELSE
    $Flag[FlagNo_RunBrkTest]=TRUE
  ENDIF
  RETURN
ELSE
  IF ( Ret <> 0) then
    ; Entweder (Ret == +1) - dann liegt keine Testanforderung vor - oder
    ; (Ret < 0) - dann wurde bereits eine Zustandsmeldung vom Treiber abgesetzt
    RETURN
  ENDIF
ENDIF
SEL_RES=SELECT(#UP,UpNo_ToBrkTestPath,TRUE); zum Bremsentest fahren
;
END
;
;-----------------------------------------------------------
;
GLOBAL DEF BrakeTestRun()
DECL E6AXIS BtStPos
INT Idx, i, Ret, IntArray[5]
INT BitfieldAxesInTest
REAL RealArray[1]
BOOL B_Park
;
; init Flag 
B_Park=FALSE
repeat
  repeat
    Ret = MD_CMD(brakeTestDevName[], "START_TEST", IntArray[], RealArray[])
  until ($mode_op<>#t1)
  Ret = MD_CMD(brakeTestDevName[], "START_TEST", IntArray[], RealArray[])
  ; Die Achsmasken aus der INI-Datei auslesen
  BitfieldAxesInTest = IntArray[1]
  BtStPos=$AXIS_ACT
  i=1
  FOR Idx = 1 TO 12
    if (( BitfieldAxesInTest b_and i) == i ) AND (B_Park == FALSE) then
      if (Idx==5) AND $PAL_MODE AND NOT $DEF_A5LINK AND $DEF_A4FIX then
        $PAL_MODE=FALSE
      endif
      repeat 
        TestAxis(Idx)
        PTP BtStPos
      until GetResult() 
      IF (FlagNo_GoToPark > 0) THEN
        B_Park = $FLAG[FlagNo_GoToPark]   
      ENDIF 
      if (Idx==5) AND NOT $PAL_MODE AND NOT $DEF_A5LINK AND $DEF_A4FIX then
        $PAL_MODE=TRUE
      endif
    endif
    i=i*2 
  ENDFOR
  WAIT FOR TRUE
  Ret = MD_CMD(brakeTestDevName[], "END_TEST", IntArray[], RealArray[])
until (( Ret == 0 ) OR (B_Park == TRUE )) 
IF (FlagNo_RunBrkTest>0) THEN
  IF ( Ret == 0) THEN
    $Flag[FlagNo_RunBrkTest]=FALSE
  ENDIF
ENDIF
END
;
;-----------------------------------------------------------
;
DEF TestAxis(AxisNr: IN)
INT AxisNr
INT Ret, NrFlag
INT IntArray[3]
REAL RealArray[1]
AxNr=AxisNr
IntArray[1] = AxisNr
Ret = MD_CMD(brakeTestDevName[], "SELECT_TARGET", IntArray[], RealArray[])
NrFlag=IntArray[1]
BtIrNr=IntArray[3]
$FLAG[NrFlag]=FALSE
IF(AxNr<7) THEN
  $VEL_AXIS[AxNr]=IntArray[2]
ELSE
  $VEL_EXTAX[AxNr-6]=IntArray[2]
ENDIF
INTERRUPT DECL BtIrNr WHEN $FLAG[NrFlag] DO Decelerate()
INTERRUPT ON BtIrNr
MoveAxis()
END
;
;-----------------------------------------------------------
;
DEF MoveAxis()
INT Ret
INT IntArray[5]
REAL RealArray[6]
E6AXIS AxisRel
$ADVANCE=0
Ret = MD_CMD(brakeTestDevName[], "GET_ROB_ANGLES", IntArray[], RealArray[])
AxisRel.A1=RealArray[1]
AxisRel.A2=RealArray[2]
AxisRel.A3=RealArray[3]
AxisRel.A4=RealArray[4]
AxisRel.A5=RealArray[5]
AxisRel.A6=RealArray[6]
Ret = MD_CMD(brakeTestDevName[], "GET_EXT_ANGLES", IntArray[], RealArray[])
AxisRel.E1=RealArray[1]
AxisRel.E2=RealArray[2]
AxisRel.E3=RealArray[3]
AxisRel.E4=RealArray[4]
AxisRel.E5=RealArray[5]
AxisRel.E6=RealArray[6]
PTP $AXIS_ACT
Ret = MD_CMD(brakeTestDevName[], "TRIGGER_TEST_RUN", IntArray[], RealArray[])
PTP_REL AxisRel
WAIT FOR TRUE
; Hier kommt man nur hin, wenn die Bewegung zu Ende gefahren wurde.
; Im Gutfall wird aber ein BRAKE / RESUME ausgeführt und damit diese Funktion verlassen
MsgQuit("BT_MAX_AXIS_MOVE", "BrkTst",,,111)
END
;
;-----------------------------------------------------------
;
DEF Decelerate()
INT Ret
INT IntArray[5]
REAL RealArray[6]
INTERRUPT OFF BtIrNr
BRAKE
Ret = MD_CMD(brakeTestDevName[], "FINISH_TEST_RUN", IntArray[], RealArray[])
if ret <> 0 then
  MsgNotify("FINISH_TEST_RUN returns %1 ", "BrkTst", ret,,110)
endif
RESUME
END
;
;-----------------------------------------------------------
;
DEFFCT BOOL GetResult()
INT Ret
INT IntArray[5]
REAL RealArray[1]
Decl CHAR DialogText[20]
DECL CHAR AxNrText[10]
;
IF (FlagNo_GoToPark > 0)THEN 
  $Flag[FlagNo_GoToPark] = FALSE
ENDIF
Ret=MD_CMD(brakeTestDevName[], "GET_RESULT", IntArray[], RealArray[])
SWITCH IntArray[1]
  CASE 0
    ; BT_BRAKE_OK
    Return TRUE
  CASE 1
    ; BT_BRAKE_WEAK
    Return TRUE
  CASE 2
    ;BT_BRAKE_NOT_OK
    DialogText[] = "BT_BRAKE_NOT_OK"
  CASE 3
    ; BT_NO_BRAKING
    DialogText[] = "BT_BRAKE_NOT_OK"
    IntArray[1]=2
  CASE 4
    ; BT_MOTION_FAULT
    DialogText[] = "BT_EVALUATION_FAILED"
  CASE 5
    ; BT_INCOMPLETE
    DialogText[] = "BT_INCOMPLETE"
  CASE 6
    ; BT_REPEAT
    Return FALSE
ENDSWITCH
IF(IntArray[2]<7) THEN
  AxNrText[]="A "
  AxNrText[2]=IntArray[2]+48
ELSE
  AxNrText[]="E "
  AxNrText[2]=IntArray[2]+42
ENDIF
MsgDialog(ret, DialogText[], "BrkTst", AxNrText[], "TryAgain", "GoToPark",,,,,,TRUE,100+IntArray[1])
if Ret==7 then
  ; Rückgabewert 7 = Softkey "TryAgain" ganz rechts
  ; Testlauf wiederholen
  Return FALSE
endif
;goto parkposition
IF (FlagNo_GoToPark > 0)THEN 
  IF (Ret == 6) THEN
    $Flag[FlagNo_GoToPark] = TRUE
    RETURN TRUE
  ENDIF
ENDIF
IF (UpNo_ToBrkTestPark>0) THEN
  SEL_RES=SELECT(#UP,UpNo_ToBrkTestPark,TRUE) ;zurückfahren vom Bremsentest
ENDIF
WAIT FOR TRUE
ParkPosReached()
ENDFCT
;
;-----------------------------------------------------------
;
GLOBAL DEF ParkPosReached()
INT Ret
INT IntArray[5]
REAL RealArray[1]
Ret = MD_CMD(brakeTestDevName[], "SIGNAL_PARK_POS", IntArray[], RealArray[])
repeat
  MsgNotify("ParkPositionReached", "BrkTst",,,100)
  halt
until false  
END
;
;-----------------------------------------------------------
;
GLOBAL DEF MasRefReq()
IF FlagNo_GoToMasRefTest > 0 THEN
  IF NOT $MasteringTest_Req_Ext AND NOT $MasteringTest_Req_Int THEN
    $Flag[FlagNo_GoToMasRefTest] = FALSE
    RETURN
  ELSE
    $Flag[FlagNo_GoToMasRefTest] = TRUE
  ENDIF
ELSE
  IF NOT $MasteringTest_Req_Ext AND NOT $MasteringTest_Req_Int THEN
    RETURN
  ENDIF
ENDIF
MasRefBefore()
IF FlagNo_GoToMasRefTest > 0 THEN
  RETURN
ENDIF
SEL_RES=SELECT(#UP,UpNo_ToMasRefPath,TRUE)
MasRefEnd()
END
;
;-----------------------------------------------------------
;
GLOBAL DEF MasRefBefore(nGroup:IN)
DECL INT nGroup, mGroup
$MasteringTest_Active = FALSE 
WHILE NOT $MasteringTest_Switch_OK
  MsgQuit("MasterReferenceSwitchFailure", "MasRef",,,100)
ENDWHILE
Err_Clear($Err)
On_Error_Proceed
mGroup = nGroup
IF NOT($Err.Number==0) THEN
  $MasteringTest_Group = 0
ELSE
  MasRefGroup(nGroup)
ENDIF
$MasteringTest_Active = FALSE
REPEAT
  $MasteringTest_Active = TRUE
  WAIT SEC 0.2
  IF NOT $MasteringTest_Active THEN
    MsgQuit("MasterReferenceNotActivated", "MasRef",,,101)
  ENDIF
UNTIL $MasteringTest_Active
END
;
;-----------------------------------------------------------
;
GLOBAL DEF MasRefEnd()
IF NOT($MasteringTest_Group==0) then
  $MasteringTest_Group = 0
  WAIT SEC 0.2
ENDIF
$MasteringTest_Active = FALSE
nLapsedTime = 0
REPEAT
  WAIT SEC 0.096
  nLapsedTime = nLapsedTime + 1
UNTIL (NOT $MasteringTest_Active AND NOT $MasteringTest_Req_Int) or (nLapsedTime > nLapsedTimeout)
IF $MasteringTest_Active THEN
  MsgQuit("MasterReferenceNotActivated", "MasRef",,,102)
ENDIF
IF FlagNo_GoToMasRefTest > 0 THEN
  IF NOT $MasteringTest_Req_Ext AND NOT $MasteringTest_Req_Int THEN
    $Flag[FlagNo_GoToMasRefTest] = FALSE
  ENDIF
ENDIF
END
;
;-----------------------------------------------------------
;
GLOBAL DEF MasRefGroup(Group :IN)
DECL INT Group, mGroup
WAIT SEC 0.2
Err_Clear($Err)
On_Error_Proceed
mGroup = Group
IF NOT($Err.Number==0) then
  MsgQuit("GroupNumberMissing", "MasRef",,,103)
  Return
ELSE
  IF (Group>3) then
    MsgQuit("GroupNumberGreaterThan3", "MasRef",,,104)
    Return
  ENDIF
  IF (Group<0) then
    MsgQuit("GroupNumberLessThan1", "MasRef",,,105)
    Return
  ENDIF
  $MasteringTest_Group = Group
  WAIT SEC 0.2
ENDIF
END
;ENDFOLD


