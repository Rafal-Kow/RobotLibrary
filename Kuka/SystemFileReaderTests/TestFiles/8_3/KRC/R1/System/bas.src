&ACCESS R
&COMMENT BASIS package
&PARAM TPVW_VERSION=8.3.18
&PARAM SUPPRESS = LoosOfPrecision UnswitchedEnum AssignmentLoosesPrecision UnusedProgram
DEF  BAS (COMMAND :IN,REAL_PAR :IN )
  ; FOLD ;%{H} %MKUKATPVW
  DECL BAS_COMMAND COMMAND
  REAL REAL_PAR
  SWITCH  COMMAND
  CASE #INITMOV
    INITMOV ( )
  CASE #INITMOVEUP
    INITMOVEUP ( )
  CASE #ACC_CP
    ACC_CP (REAL_PAR )
  CASE #ACC_PTP
    ACC_PTP (REAL_PAR )
  CASE #VEL_CP
    VEL_CP (REAL_PAR )
  CASE #VEL_PTP
    VEL_PTP (REAL_PAR )
  CASE #TOOL
    TOOL (REAL_PAR )
  CASE #BASE
    BASE (REAL_PAR )
  CASE #EX_BASE
    EX_BASE (REAL_PAR )
  CASE #LK_BASE
    LK_BASE(REAL_PAR )
  CASE #PTP_DAT
    PTP_DAT ( )
  CASE #CP_DAT
    CP_DAT ( )
  ENDSWITCH
END
DEF  INITMOV ( )
  INT I
  ; PTP-Parameters:
  ACC_PTP (100.0 ) ; ptp acceleration 100% = DEF_ACC_PTP
  VEL_PTP (100.0 ) ; ptp velocity 100% = DEF_VEL_PTP
  ; CP-Parameters:
  ACC_CP (100.0 ) ; path acceleration 100%  =  DEF_ACC_CP
  $ACC.ORI1=DEF_ACC_ORI1 ; swivel acceleration
  $ACC.ORI2=DEF_ACC_ORI2 ; rotation acceleration
  VEL_CP (DEF_VEL_CP ) ; path velocity
  $VEL.ORI1=DEF_VEL_ORI1 ; swivel velocity
  $VEL.ORI2=DEF_VEL_ORI2 ; rotation velocity
  ; Parameters for Approximation:
  $APO.CPTP=DEF_APO_CPTP ; PTP-Approximation
  $APO.CDIS=DEF_APO_CDIS ; Distance-Approximation
  $APO.CVEL=DEF_APO_CVEL ; Speed-Approximation
  $APO.CORI=DEF_APO_CORI ; Orientation-Approximation
  $FILTER=$DEF_FLT_PTP ; filter
  $ADVANCE=DEF_ADVANCE ; advance
  $ORI_TYPE=#VAR ; variable orientation
  $CIRC_TYPE=DEF_CIRC_TYPE ; CIRC-orientation
  IF $KINCLASS<>#NONE THEN
    BASE (0 ) ; Activating Base $WORLD
    TOOL (0 ) ; Activating Tool and Default-Load
  ENDIF
  IF $TCP_IPO==TRUE THEN
    $IPO_MODE=#BASE
  ENDIF
  IF $ADAP_ACC<>#NONE THEN
    IF LOAD_A1_DATA.M<0 THEN
      $LOAD_A1.M=0
      $LOAD_A1.CM={X 0.0, Y 0.0, Z 0.0, A 0.0, B 0.0, C 0.0}
      $LOAD_A1.J={X 0.0, Y 0.0, Z 0.0}
    ELSE
      $LOAD_A1.M=LOAD_A1_DATA.M
      $LOAD_A1.CM=LOAD_A1_DATA.CM
      $LOAD_A1.J=LOAD_A1_DATA.J
    ENDIF
    IF LOAD_A2_DATA.M<0 THEN
      $LOAD_A2.M=0
      $LOAD_A2.CM={X 0.0, Y 0.0, Z 0.0, A 0.0, B 0.0, C 0.0}
      $LOAD_A2.J={X 0.0, Y 0.0, Z 0.0}
    ELSE
      $LOAD_A2.M=LOAD_A2_DATA.M
      $LOAD_A2.CM=LOAD_A2_DATA.CM
      $LOAD_A2.J=LOAD_A2_DATA.J
    ENDIF
    IF LOAD_A3_DATA.M<0 THEN
      $LOAD_A3.M=$DEF_LA3_M
      $LOAD_A3.CM=$DEF_LA3_CM
      $LOAD_A3.J=$DEF_LA3_J
    ELSE
      $LOAD_A3.M=LOAD_A3_DATA.M
      $LOAD_A3.CM=LOAD_A3_DATA.CM
      $LOAD_A3.J=LOAD_A3_DATA.J
      IF (($LOAD_A3.M<>0) AND ($LOAD_A3.J.X==0) AND ($LOAD_A3.J.Y==0) AND ($LOAD_A3.J.Z==0)) THEN
        $LOAD_A3.J=$DEF_LA3_J
      ENDIF
    ENDIF
  ENDIF
  ; standard group definition
  COMPL_GROUP=1
  FOR I=1 TO  $EX_AX_NUM
    COMPL_GROUP=COMPL_GROUP*2+1
  ENDFOR
  $ACT_GROUP=COMPL_GROUP
END
DEF  INITMOVEUP ( )
  INT I
  ; PTP-Parameters:
  ACC_PTP (100.0 ) ; ptp acceleration 100% = DEF_ACC_PTP
  VEL_PTP (100.0 ) ; ptp velocity 100% = DEF_VEL_PTP
  ; CP-Parameters:
  ACC_CP (100.0 ) ; path acceleration 100%  =  DEF_ACC_CP
  $ACC.ORI1=DEF_ACC_ORI1 ; swivel acceleration
  $ACC.ORI2=DEF_ACC_ORI2 ; rotation acceleration
  VEL_CP (DEF_VEL_CP ) ; path velocity
  $VEL.ORI1=DEF_VEL_ORI1 ; swivel velocity
  $VEL.ORI2=DEF_VEL_ORI2 ; rotation velocity
  ; Parameters for Approximation:
  $APO.CPTP=DEF_APO_CPTP ; PTP-Approximation
  $APO.CDIS=DEF_APO_CDIS ; Distance-Approximation
  $APO.CVEL=DEF_APO_CVEL ; Speed-Approximation
  $APO.CORI=DEF_APO_CORI ; Orientation-Approximation
  $ADVANCE=DEF_ADVANCE ; advance
  $ORI_TYPE=#VAR ; variable orientation
  $CIRC_TYPE=DEF_CIRC_TYPE ; CIRC-orientation
  IF  NOT CALLBYSELECT THEN
    $FILTER=$DEF_FLT_PTP ; filter
    IF $KINCLASS<>#NONE THEN
      BASE (0 ) ; Activating Base $WORLD
      TOOL (0 ) ; Activating Tool and Default-Load
    ENDIF
    IF $TCP_IPO==TRUE THEN
      $IPO_MODE=#BASE
    ENDIF
    IF $ADAP_ACC<>#NONE THEN
      IF LOAD_A1_DATA.M<0 THEN
        $LOAD_A1.M=0
        $LOAD_A1.CM={X 0.0, Y 0.0, Z 0.0, A 0.0, B 0.0, C 0.0}
        $LOAD_A1.J={X 0.0, Y 0.0, Z 0.0}
      ELSE
        $LOAD_A1.M=LOAD_A1_DATA.M
        $LOAD_A1.CM=LOAD_A1_DATA.CM
        $LOAD_A1.J=LOAD_A1_DATA.J
      ENDIF
      IF LOAD_A2_DATA.M<0 THEN
        $LOAD_A2.M=0
        $LOAD_A2.CM={X 0.0, Y 0.0, Z 0.0, A 0.0, B 0.0, C 0.0}
        $LOAD_A2.J={X 0.0, Y 0.0, Z 0.0}
      ELSE
        $LOAD_A2.M=LOAD_A2_DATA.M
        $LOAD_A2.CM=LOAD_A2_DATA.CM
        $LOAD_A2.J=LOAD_A2_DATA.J
      ENDIF
      IF LOAD_A3_DATA.M<0 THEN
        $LOAD_A3.M=$DEF_LA3_M
        $LOAD_A3.CM=$DEF_LA3_CM
        $LOAD_A3.J=$DEF_LA3_J
      ELSE
        $LOAD_A3.M=LOAD_A3_DATA.M
        $LOAD_A3.CM=LOAD_A3_DATA.CM
        $LOAD_A3.J=LOAD_A3_DATA.J
        IF (($LOAD_A3.M<>0) AND ($LOAD_A3.J.X==0) AND ($LOAD_A3.J.Y==0) AND ($LOAD_A3.J.Z==0)) THEN
          $LOAD_A3.J=$DEF_LA3_J
        ENDIF
      ENDIF
    ENDIF
    ; standard group definition
    COMPL_GROUP=1
    FOR I=1 TO  $EX_AX_NUM
      COMPL_GROUP=COMPL_GROUP*2+1
    ENDFOR
    $ACT_GROUP=COMPL_GROUP
  ENDIF
  CALLBYSELECT=FALSE
END
DEF  ACC_CP (ACC_FACTOR :IN )
  REAL ACC_FACTOR ; [%]
  IF ACC_FACTOR>100.0 THEN
    $ACC.CP=DEF_ACC_CP
    $ACC.ORI1=DEF_ACC_ORI1
    $ACC.ORI2=DEF_ACC_ORI2
  ELSE
    $ACC.CP=DEF_ACC_CP*ACC_FACTOR/100.0
    $ACC.ORI1=DEF_ACC_ORI1*ACC_FACTOR/100.0
    $ACC.ORI2=DEF_ACC_ORI2*ACC_FACTOR/100.0
  ENDIF
END
DEF  ACC_PTP (ACC_FACTOR :IN )
  REAL ACC_FACTOR ; [%]
  REAL ACC
  INT I
  CONTINUE
  IF $ADAP_ACC==#NONE THEN
    IF DEF_ACC_PTP>100 THEN
      DEF_ACC_PTP=100
    ENDIF
    IF ACC_FACTOR>100.0 THEN
      ACC=DEF_ACC_PTP
    ELSE
      ACC=DEF_ACC_PTP*ACC_FACTOR/100.0
    ENDIF
  ELSE
    ACC=ACC_FACTOR
  ENDIF
  FOR I=1 TO  6
    $ACC_AXIS[I]=ACC
  ENDFOR
  FOR I=1 TO  $EX_AX_NUM
    CHECK_REDEXAX_ACC(I)
    $ACC_EXTAX[I]=ACC*RedAccExAx[I]/100.0
  ENDFOR
END

GLOBAL DEFFCT CP SVEL_CP (PARAMS :IN )
  REAL AX_VEL
  DECL CP RET_VEL
  DECL VW_SPARA_TYP PARAMS
  DECL REAL VEL_CP
  VEL_CP = PARAMS.VB*0.001
  IF VEL_CP>DEF_VEL_CP THEN
    RET_VEL.CP=DEF_VEL_CP
  ELSE
    RET_VEL.CP=VEL_CP
  ENDIF
  RET_VEL.ORI1=DEF_VEL_ORIS
  ;for Spline-HFP
  ON_ERROR_PROCEED
  AX_VEL=PARAMS.AXIS_VEL
  IF $ERR.NUMBER>0 THEN
    ERR_CLEAR($ERR)
  ELSE
    IF PARAMS.AXIS_VEL>100.0 THEN
      AX_VEL=DEF_VEL_PTP
    ELSE
      AX_VEL=DEF_VEL_PTP*PARAMS.AXIS_VEL/100.0
    ENDIF
    
    $VEL_AXIS[1]=AX_VEL
    $VEL_AXIS[2]=AX_VEL
    $VEL_AXIS[3]=AX_VEL
    $VEL_AXIS[4]=AX_VEL
    $VEL_AXIS[5]=AX_VEL
    $VEL_AXIS[6]=AX_VEL
    IF RedVelExAx[1]>100.0 THEN
      RedVelExAx[1]=100.0
    ENDIF
    IF RedVelExAx[1]<1.0 THEN
      RedVelExAx[1]=1.0
    ENDIF
    IF RedVelExAx[2]>100.0 THEN
      RedVelExAx[2]=100.0
    ENDIF
    IF RedVelExAx[2]<1.0 THEN
      RedVelExAx[2]=1.0
    ENDIF
    IF RedVelExAx[3]>100.0 THEN
      RedVelExAx[3]=100.0
    ENDIF
    IF RedVelExAx[3]<1.0 THEN
      RedVelExAx[3]=1.0
    ENDIF
    IF RedVelExAx[4]>100.0 THEN
      RedVelExAx[4]=100.0
    ENDIF
    IF RedVelExAx[4]<1.0 THEN
      RedVelExAx[4]=1.0
    ENDIF
    IF RedVelExAx[5]>100.0 THEN
      RedVelExAx[5]=100.0
    ENDIF
    IF RedVelExAx[5]<1.0 THEN
      RedVelExAx[5]=1.0
    ENDIF
    IF RedVelExAx[6]>100.0 THEN
      RedVelExAx[6]=100.0
    ENDIF
    IF RedVelExAx[6]<1.0 THEN
      RedVelExAx[6]=1.0
    ENDIF
    $VEL_EXTAX[1]=AX_VEL*RedVelExAx[1]/100.0
    $VEL_EXTAX[2]=AX_VEL*RedVelExAx[2]/100.0
    $VEL_EXTAX[3]=AX_VEL*RedVelExAx[3]/100.0
    $VEL_EXTAX[4]=AX_VEL*RedVelExAx[4]/100.0
    $VEL_EXTAX[5]=AX_VEL*RedVelExAx[5]/100.0
    $VEL_EXTAX[6]=AX_VEL*RedVelExAx[6]/100.0
  ENDIF
  ;return CP-structure
  RETURN RET_VEL
ENDFCT

GLOBAL DEFFCT REAL SVEL_JOINT (PARAMS :IN)
  REAL VEL_FACTOR ; [%]
  REAL VEL
  DECL VW_SPARA_TYP PARAMS
  VEL_FACTOR = PARAMS.VB
  IF VEL_FACTOR>100.0 THEN
    VEL=DEF_VEL_PTP
  ELSE
    VEL=DEF_VEL_PTP*VEL_FACTOR/100.0
  ENDIF
  ;$VEL_AXIS[1]=VEL
  $VEL_AXIS[2]=VEL
  $VEL_AXIS[3]=VEL
  $VEL_AXIS[4]=VEL
  $VEL_AXIS[5]=VEL
  $VEL_AXIS[6]=VEL
  IF RedVelExAx[1]>100.0 THEN
      RedVelExAx[1]=100.0
    ENDIF
    IF RedVelExAx[1]<1.0 THEN
      RedVelExAx[1]=1.0
    ENDIF
    IF RedVelExAx[2]>100.0 THEN
      RedVelExAx[2]=100.0
    ENDIF
    IF RedVelExAx[2]<1.0 THEN
      RedVelExAx[2]=1.0
    ENDIF
    IF RedVelExAx[3]>100.0 THEN
      RedVelExAx[3]=100.0
    ENDIF
    IF RedVelExAx[3]<1.0 THEN
      RedVelExAx[3]=1.0
    ENDIF
    IF RedVelExAx[4]>100.0 THEN
      RedVelExAx[4]=100.0
    ENDIF
    IF RedVelExAx[4]<1.0 THEN
      RedVelExAx[4]=1.0
    ENDIF
    IF RedVelExAx[5]>100.0 THEN
      RedVelExAx[5]=100.0
    ENDIF
    IF RedVelExAx[5]<1.0 THEN
      RedVelExAx[5]=1.0
    ENDIF
    IF RedVelExAx[6]>100.0 THEN
      RedVelExAx[6]=100.0
    ENDIF
    IF RedVelExAx[6]<1.0 THEN
      RedVelExAx[6]=1.0
    ENDIF
    $VEL_EXTAX[1]=VEL*RedVelExAx[1]/100.0
    $VEL_EXTAX[2]=VEL*RedVelExAx[2]/100.0
    $VEL_EXTAX[3]=VEL*RedVelExAx[3]/100.0
    $VEL_EXTAX[4]=VEL*RedVelExAx[4]/100.0
    $VEL_EXTAX[5]=VEL*RedVelExAx[5]/100.0
    $VEL_EXTAX[6]=VEL*RedVelExAx[6]/100.0
  RETURN VEL
ENDFCT

DEF  CHECK_REDEXAX_ACC(I :IN )
  INT I
  IF RedAccExAx[I]>100.0 THEN
    RedAccExAx[I]=100.0
  ENDIF
  IF RedAccExAx[I]<1.0 THEN
    RedAccExAx[I]=1.0
  ENDIF
END
DEF CHECK_REDEXAX_VEL(I :IN )
  INT I
  IF RedVelExAx[I]>100.0 THEN
    RedVelExAx[I]=100.0
  ENDIF
  IF RedVelExAx[I]<1.0 THEN
    RedVelExAx[I]=1.0
  ENDIF
END
DEF  VEL_CP (VEL_VALUE :IN )
  REAL VEL_VALUE ; [m/s]
  IF VEL_VALUE>DEF_VEL_CP THEN
    $VEL.CP=DEF_VEL_CP
  ELSE
    $VEL.CP=VEL_VALUE*DEF_VEL_FACT
  ENDIF
END
DEF  VEL_PTP (VEL_FACTOR :IN )
  REAL VEL_FACTOR ; [%]
  REAL VEL
  INT I
  IF VEL_FACTOR>100.0 THEN
    VEL=DEF_VEL_PTP
  ELSE
    VEL=DEF_VEL_PTP*VEL_FACTOR/100.0
  ENDIF
  FOR I=1 TO  6
    $VEL_AXIS[I]=VEL
  ENDFOR
  FOR I=1 TO  $EX_AX_NUM
  CHECK_REDEXAX_VEL(I)
  $VEL_EXTAX[I]=VEL*RedVelExAx[I]/100.0
  ENDFOR
END
GLOBAL DEFFCT CONT SAPO(PARAMS: IN)
  DECL VW_SPARA_TYP PARAMS
  DECL CONT RET_APO
   RET_APO.CDIS = PARAMS.APO_DIST
   RET_APO.CPTP = DEF_APO_CPTP
   RET_APO.CORI = DEF_APO_CORIS
   RETURN RET_APO
ENDFCT
DEF  TOOL (TOOL_NO :IN )
  INT TOOL_NO
  IF (TOOL_NO==0) THEN
    $TOOL=$NULLFRAME
    IF $ADAP_ACC<>#NONE THEN
      $LOAD.M=$DEF_L_M
      $LOAD.CM=$DEF_L_CM
      $LOAD.J=$DEF_L_J
    ENDIF
  ELSE
    CONTINUE
    $TOOL=TOOL_DATA[TOOL_NO]
    IF $ADAP_ACC<>#NONE THEN
      IF LOAD_DATA[TOOL_NO].M<0 THEN
        $LOAD.M=$DEF_L_M
        $LOAD.CM=$DEF_L_CM
        $LOAD.J=$DEF_L_J
      ELSE
        $LOAD.M=LOAD_DATA[TOOL_NO].M
        $LOAD.CM=LOAD_DATA[TOOL_NO].CM
        $LOAD.J=LOAD_DATA[TOOL_NO].J
        IF (($LOAD.M<>0) AND ($LOAD.J.X==0) AND ($LOAD.J.Y==0) AND ($LOAD.J.Z==0)) THEN
          $LOAD.J=$DEF_L_J
        ENDIF
      ENDIF
    ENDIF
  ENDIF
  CONTINUE
  $ACT_TOOL=TOOL_NO
END

GLOBAL DEFFCT LOAD SLOAD (TOOL_NO :IN)
  INT TOOL_NO
  DECL LOAD RET_LOAD
  RET_LOAD = $LOAD
  IF (TOOL_NO==0) THEN
    IF $ADAP_ACC<>#NONE THEN
      RET_LOAD.M=$DEF_L_M
      RET_LOAD.CM=$DEF_L_CM
      RET_LOAD.J=$DEF_L_J
    ENDIF
  ELSE
    ;CONTINUE
    IF $ADAP_ACC<>#NONE THEN
      IF LOAD_DATA[TOOL_NO].M<0 THEN
        RET_LOAD.M=$DEF_L_M
        RET_LOAD.CM=$DEF_L_CM
        RET_LOAD.J=$DEF_L_J
      ELSE
        RET_LOAD.M=LOAD_DATA[TOOL_NO].M
        RET_LOAD.CM=LOAD_DATA[TOOL_NO].CM
        RET_LOAD.J=LOAD_DATA[TOOL_NO].J
        IF ((RET_LOAD.M<>0) AND (RET_LOAD.J.X==0) AND (RET_LOAD.J.Y==0) AND (RET_LOAD.J.Z==0)) THEN
          RET_LOAD.J=$DEF_L_J
        ENDIF
      ENDIF
    ENDIF
  ENDIF
  ;CONTINUE
RETURN RET_LOAD
ENDFCT

GLOBAL DEFFCT IPO_MODE SIPO_MODE (BASE_NR :IN)
  DECL INT BASE_NR
  DECL IPO_MODE RET_IPO_MODE
  IF (BASE_NR <> 0) THEN
    IF (BASE_TYPE[BASE_NR] == #TCP) THEN
      RET_IPO_MODE=#TCP 
    ELSE
      RET_IPO_MODE=#BASE 
    ENDIF
  ELSE
    RET_IPO_MODE=#BASE 
  ENDIF
  RETURN RET_IPO_MODE
ENDFCT

GLOBAL DEFFCT FRAME STOOL(TOOL_NO :IN)
  INT TOOL_NO
  DECL FRAME RET_TOOL
    IF (TOOL_NO==0) THEN
    RET_TOOL=$NULLFRAME
  ELSE
   ; CONTINUE
    RET_TOOL=TOOL_DATA[TOOL_NO]
  ENDIF
  ;CONTINUE
  $ACT_TOOL=TOOL_NO
RETURN RET_TOOL
ENDFCT
;*** Set Spline Tool and Base
GLOBAL DEFFCT FRAME STOOLBASE(TOOL_NO :IN,BASE_NO:IN)
  INT TOOL_NO, BASE_NO, MACH_INDEX,COOP_KRC_INDEX
  DECL ESYS MECH_TYPE
  DECL FRAME RET_TOOL
  DECL FRAME RET_BASE
  ;*********Set TOOL*************
  IF (TOOL_NO==0) THEN
    RET_TOOL=$NULLFRAME
  ELSE
    RET_TOOL=TOOL_DATA[TOOL_NO]
  ENDIF
  $ACT_TOOL=TOOL_NO
  ;******************************
  ;*********Set Base*************
  IF (BASE_NO == 0) THEN
    $BASE=$WORLD
    $ACT_BASE=BASE_NO ; Storing actual Base-Number in global variable
  ELSE
    MACH_INDEX = MACHINE_FRAME_DAT[BASE_NO].MACH_DEF_INDEX
	IF (MACH_INDEX > 0) THEN
	  MECH_TYPE = MACHINE_DEF[MACH_INDEX].MECH_TYPE
	  COOP_KRC_INDEX = MACHINE_DEF[MACH_INDEX].COOP_KRC_INDEX
      IF (MECH_TYPE == #NONE) THEN
        IF (BASE_NO <= MAX_BASE) THEN
          $BASE=BASE_DATA[BASE_NO]
          $ACT_BASE=BASE_NO ; Storing actual Base-Number in global variable
        ENDIF
      ENDIF
      IF (MECH_TYPE == #ROBOT) THEN
        IF (COOP_KRC_INDEX > 1) THEN	
          ; Linking to a frame - end-of-arm tool
          $BASE=LK(MACHINE_DEF[MACH_INDEX].ROOT, $COOP_KRC[COOP_KRC_INDEX].IP_ADDR[], BASE_DATA[BASE_NO], MECH_TYPE)
          $ACT_BASE=BASE_NO
        ENDIF
        IF (COOP_KRC_INDEX == 1) THEN
          $BASE=BASE_DATA[BASE_NO]
          $ACT_BASE=BASE_NO ; Storing actual Base-Number in global variable
        ENDIF
      ENDIF
      IF ((MECH_TYPE == #EASYS) OR (MECH_TYPE == #EBSYS) OR (MECH_TYPE == #ECSYS) OR (MECH_TYPE == #EDSYS) OR (MECH_TYPE == #EESYS) OR (MECH_TYPE == #EFSYS) OR (MECH_TYPE == #ERSYS)) THEN
        IF (COOP_KRC_INDEX > 1) THEN
          $BASE=LK(MACHINE_DEF[MACH_INDEX].ROOT, $COOP_KRC[COOP_KRC_INDEX].IP_ADDR[], BASE_DATA[BASE_NO], MECH_TYPE)
          $ACT_BASE=BASE_NO
        ENDIF
        IF (COOP_KRC_INDEX == 1) THEN
          IF MACH_INDEX > 0 THEN
            $BASE =EK(MACHINE_DEF[MACH_INDEX].ROOT,MECH_TYPE,BASE_DATA[BASE_NO])
          ENDIF
          ;$ACT_EX_AX=BASE_NO
        ENDIF         
      ENDIF  
      IF (MECH_TYPE == #CONVEYOR) THEN
        repeat
          halt;not programed yet
        until false
      ENDIF
    ELSE
      IF (BASE_NO <= MAX_BASE) THEN
        $BASE=BASE_DATA[BASE_NO]
        $ACT_BASE=BASE_NO ; Storing actual Base-Number in global variable
      ENDIF
    ENDIF
  ENDIF 
  ;******************************
RETURN RET_TOOL
ENDFCT
;*** Set Tool and Base for Spline
;****BASE
GLOBAL DEFFCT FRAME SBASE(BASE_NO :IN)
  INT BASE_NO
  FRAME RET_BASE
  IF (BASE_NO == 0) THEN
	 RET_BASE = SBASE_BASIC(0)
     ;RETURN
   ELSE
     IF (MACHINE_FRAME_DAT[BASE_NO].MACH_DEF_INDEX > 0) THEN
       IF (MACHINE_DEF[MACHINE_FRAME_DAT[BASE_NO].MACH_DEF_INDEX].MECH_TYPE == #NONE) THEN
         IF (BASE_NO <= MAX_BASE) THEN
           RET_BASE = SBASE_BASIC(BASE_NO)
         ENDIF
       ENDIF
       
       IF (MACHINE_DEF[MACHINE_FRAME_DAT[BASE_NO].MACH_DEF_INDEX].MECH_TYPE == #ROBOT) THEN
         IF (MACHINE_DEF[MACHINE_FRAME_DAT[BASE_NO].MACH_DEF_INDEX].COOP_KRC_INDEX > 1) THEN	
           RET_BASE = LK_SBASE(BASE_NO)
         ENDIF
         IF (MACHINE_DEF[MACHINE_FRAME_DAT[BASE_NO].MACH_DEF_INDEX].COOP_KRC_INDEX == 1) THEN
           RET_BASE = SBASE_BASIC(BASE_NO)
         ENDIF
       ENDIF
      
       IF ((MACHINE_DEF[MACHINE_FRAME_DAT[BASE_NO].MACH_DEF_INDEX].MECH_TYPE == #EASYS) OR (MACHINE_DEF[MACHINE_FRAME_DAT[BASE_NO].MACH_DEF_INDEX].MECH_TYPE == #EBSYS) OR (MACHINE_DEF[MACHINE_FRAME_DAT[BASE_NO].MACH_DEF_INDEX].MECH_TYPE == #ECSYS) OR (MACHINE_DEF[MACHINE_FRAME_DAT[BASE_NO].MACH_DEF_INDEX].MECH_TYPE == #EDSYS) OR (MACHINE_DEF[MACHINE_FRAME_DAT[BASE_NO].MACH_DEF_INDEX].MECH_TYPE == #EESYS) OR (MACHINE_DEF[MACHINE_FRAME_DAT[BASE_NO].MACH_DEF_INDEX].MECH_TYPE == #EFSYS) OR (MACHINE_DEF[MACHINE_FRAME_DAT[BASE_NO].MACH_DEF_INDEX].MECH_TYPE == #ERSYS)) THEN
         IF (MACHINE_DEF[MACHINE_FRAME_DAT[BASE_NO].MACH_DEF_INDEX].COOP_KRC_INDEX > 1) THEN
           RET_BASE = LK_SBASE(BASE_NO)
         ENDIF
         IF (MACHINE_DEF[MACHINE_FRAME_DAT[BASE_NO].MACH_DEF_INDEX].COOP_KRC_INDEX == 1) THEN
           RET_BASE = EX_SBASE(BASE_NO)
         ENDIF         
       ENDIF  
            
       IF (MACHINE_DEF[MACHINE_FRAME_DAT[BASE_NO].MACH_DEF_INDEX].MECH_TYPE == #CONVEYOR) THEN
         repeat
           halt;not programed yet
         until false
       ENDIF
     ELSE
       IF (BASE_NO <= MAX_BASE) THEN
          RET_BASE = SBASE_BASIC(BASE_NO)
       ENDIF
     ENDIF
   ENDIF 
  
   RETURN RET_BASE
 ENDFCT 
DEF  BASE (BASE_NO :IN )
  INT BASE_NO
  IF (BASE_NO==0) THEN
    CONTINUE
    $BASE=$WORLD
  ELSE
    CONTINUE
    $BASE=BASE_DATA[BASE_NO]
  ENDIF
  CONTINUE
  $ACT_BASE=BASE_NO ; Storing actual Base-Number in global variable
  CONTINUE
  $ACT_EX_AX=-1
END

GLOBAL DEFFCT CP SACC_CP (PARAMS :IN)
  REAL AX_ACC
  DECL VW_SPARA_TYP PARAMS	
  DECL CP RET_ACC
  PARAMS.ACC=PARAMS.AXIS_ACC
  IF PARAMS.ACC>100.0 THEN
    RET_ACC.CP=DEF_ACC_CP
    RET_ACC.ORI1=DEF_ACC_ORIS
  ELSE
    RET_ACC.CP=DEF_ACC_CP*PARAMS.ACC/100.0
    RET_ACC.ORI1=DEF_ACC_ORIS*PARAMS.ACC/100.0
  ENDIF
  ;for Spline-HFP
  IF $ADAP_ACC==#NONE THEN;
    IF PARAMS.AXIS_ACC>100.0 THEN
      AX_ACC=DEF_ACC_SPTP
    ELSE
      AX_ACC=DEF_ACC_SPTP*PARAMS.AXIS_ACC/100.0
    ENDIF
  ELSE
    AX_ACC=DEF_ACC_SPTP*PARAMS.AXIS_ACC/100.0
  ENDIF
  
  $ACC_AXIS[1]=AX_ACC
  $ACC_AXIS[2]=AX_ACC
  $ACC_AXIS[3]=AX_ACC
  $ACC_AXIS[4]=AX_ACC
  $ACC_AXIS[5]=AX_ACC
  $ACC_AXIS[6]=AX_ACC
  IF RedAccExAx[1]>100.0 THEN
    RedAccExAx[1]=100.0
  ENDIF
  IF RedAccExAx[1]<1.0 THEN
    RedAccExAx[1]=1.0
  ENDIF
  IF RedAccExAx[2]>100.0 THEN
    RedAccExAx[2]=100.0
  ENDIF
  IF RedAccExAx[2]<1.0 THEN
    RedAccExAx[2]=1.0
  ENDIF
  IF RedAccExAx[3]>100.0 THEN
    RedAccExAx[3]=100.0
  ENDIF
  IF RedAccExAx[3]<1.0 THEN
    RedAccExAx[3]=1.0
  ENDIF
  IF RedAccExAx[4]>100.0 THEN
    RedAccExAx[4]=100.0
  ENDIF
  IF RedAccExAx[4]<1.0 THEN
    RedAccExAx[4]=1.0
  ENDIF
  IF RedAccExAx[5]>100.0 THEN
    RedAccExAx[5]=100.0
  ENDIF
  IF RedAccExAx[5]<1.0 THEN
    RedAccExAx[5]=1.0
  ENDIF
  IF RedAccExAx[6]>100.0 THEN
    RedAccExAx[6]=100.0
  ENDIF
  IF RedAccExAx[6]<1.0 THEN
    RedAccExAx[6]=1.0
  ENDIF
  $ACC_EXTAX[1]=AX_ACC*RedAccExAx[1]/100.0
  $ACC_EXTAX[2]=AX_ACC*RedAccExAx[2]/100.0
  $ACC_EXTAX[3]=AX_ACC*RedAccExAx[3]/100.0
  $ACC_EXTAX[4]=AX_ACC*RedAccExAx[4]/100.0
  $ACC_EXTAX[5]=AX_ACC*RedAccExAx[5]/100.0
  $ACC_EXTAX[6]=AX_ACC*RedAccExAx[6]/100.0
  ;return CP-structure
  RETURN RET_ACC
ENDFCT

GLOBAL DEFFCT REAL SACC_JOINT (PARAMS :IN)
  DECL VW_SPARA_TYP PARAMS
  REAL AX_ACC
  IF PARAMS.ACC>100.0 THEN
    AX_ACC=DEF_ACC_SPTP
  ELSE
    AX_ACC=DEF_ACC_SPTP*PARAMS.ACC/100.0
  ENDIF
  ;$ACC_AXIS[1]=AX_ACC
  $ACC_AXIS[2]=AX_ACC
  $ACC_AXIS[3]=AX_ACC
  $ACC_AXIS[4]=AX_ACC
  $ACC_AXIS[5]=AX_ACC
  $ACC_AXIS[6]=AX_ACC
  IF RedAccExAx[1]>100.0 THEN
    RedAccExAx[1]=100.0
  ENDIF
  IF RedAccExAx[1]<1.0 THEN
    RedAccExAx[1]=1.0
  ENDIF
  IF RedAccExAx[2]>100.0 THEN
    RedAccExAx[2]=100.0
  ENDIF
  IF RedAccExAx[2]<1.0 THEN
    RedAccExAx[2]=1.0
  ENDIF
  IF RedAccExAx[3]>100.0 THEN
    RedAccExAx[3]=100.0
  ENDIF
  IF RedAccExAx[3]<1.0 THEN
    RedAccExAx[3]=1.0
  ENDIF
  IF RedAccExAx[4]>100.0 THEN
    RedAccExAx[4]=100.0
  ENDIF
  IF RedAccExAx[4]<1.0 THEN
    RedAccExAx[4]=1.0
  ENDIF
  IF RedAccExAx[5]>100.0 THEN
    RedAccExAx[5]=100.0
  ENDIF
  IF RedAccExAx[5]<1.0 THEN
    RedAccExAx[5]=1.0
  ENDIF
  IF RedAccExAx[6]>100.0 THEN
    RedAccExAx[6]=100.0
  ENDIF
  IF RedAccExAx[6]<1.0 THEN
    RedAccExAx[6]=1.0
  ENDIF
  $ACC_EXTAX[1]=AX_ACC*RedAccExAx[1]/100.0
  $ACC_EXTAX[2]=AX_ACC*RedAccExAx[2]/100.0
  $ACC_EXTAX[3]=AX_ACC*RedAccExAx[3]/100.0
  $ACC_EXTAX[4]=AX_ACC*RedAccExAx[4]/100.0
  $ACC_EXTAX[5]=AX_ACC*RedAccExAx[5]/100.0
  $ACC_EXTAX[6]=AX_ACC*RedAccExAx[6]/100.0
  RETURN AX_ACC
ENDFCT

GLOBAL DEFFCT FRAME SBASE_BASIC(BASE_NO :IN )
  INT BASE_NO
  FRAME RET_BASE
  IF (BASE_NO==0) THEN
    ;CONTINUE
    RET_BASE=$WORLD
  ELSE
    ;CONTINUE
    RET_BASE=BASE_DATA[BASE_NO]
  ENDIF
  ;CONTINUE
  $ACT_BASE=BASE_NO ; Storing actual Base-Number in global variable
  ;CONTINUE
  ;$ACT_EX_AX=-1
  RETURN RET_BASE
ENDFCT

GLOBAL DEFFCT ORI_TYPE SORI_TYP (P_BLOCK :IN,P_POINT :IN)
  DECL VW_SPARA_TYP P_BLOCK
  DECL VW_SPARA_TYP P_POINT
  IF(P_BLOCK.ORITYP == #CONSTANT) THEN
   RETURN P_BLOCK.ORITYP
  ELSE
   RETURN P_POINT.ORITYP
  ENDIF
ENDFCT

DEF  EX_BASE (BASE_NO :IN )
  INT BASE_NO
  INT MACH_INDEX
  CONTINUE
  IF BASE_NO>0 THEN
     MACH_INDEX = MACHINE_FRAME_DAT[BASE_NO].MACH_DEF_INDEX
     IF MACH_INDEX > 0 THEN
        $BASE=EK(MACHINE_DEF[MACH_INDEX].ROOT,MACHINE_DEF[MACH_INDEX].MECH_TYPE,BASE_DATA[BASE_NO])
     ENDIF
  ENDIF
  CONTINUE
  $ACT_BASE=-1
  CONTINUE
  $ACT_EX_AX=BASE_NO
END

DEFFCT FRAME EX_SBASE(BASE_NO :IN )
  INT BASE_NO
  INT MACH_INDEX
  FRAME RET_BASE
  ;CONTINUE
  IF BASE_NO>0 THEN
     MACH_INDEX = MACHINE_FRAME_DAT[BASE_NO].MACH_DEF_INDEX
     IF MACH_INDEX > 0 THEN
        RET_BASE=EK(MACHINE_DEF[MACH_INDEX].ROOT,MACHINE_DEF[MACH_INDEX].MECH_TYPE,BASE_DATA[BASE_NO])
     ENDIF
  ENDIF
  ;CONTINUE
  ;$ACT_BASE=-1
  ;CONTINUE
  $ACT_EX_AX=BASE_NO
  RETURN RET_BASE
ENDFCT

GLOBAL DEFFCT REAL SGEAR_JERK (PARAMS :IN )
  DECL VW_SPARA_TYP PARAMS
  REAL GEAR_JERK
  IF PARAMS.GEAR_JERK>100.0 THEN
    GEAR_JERK=DEF_GEAR_JERK
  ELSE
    GEAR_JERK=DEF_GEAR_JERK*PARAMS.GEAR_JERK/100.0
  ENDIF
  ;$GEAR_JERK[1]=GEAR_JERK
  $GEAR_JERK[2]=GEAR_JERK
  $GEAR_JERK[3]=GEAR_JERK
  $GEAR_JERK[4]=GEAR_JERK
  $GEAR_JERK[5]=GEAR_JERK
  $GEAR_JERK[6]=GEAR_JERK
  RETURN GEAR_JERK
ENDFCT

GLOBAL DEFFCT JERK_STRUC SJERK (PARAMS :IN )
  DECL JERK_STRUC RET_JERK
  DECL VW_SPARA_TYP PARAMS
  REAL GEAR_JERK, J_FACTOR, J_C0, J_F0, J_D3
  
  PARAMS.JERK_FAC=PARAMS.GEAR_JERK
  ;GEAR_JERK[1..6]for Spline-HFP
  IF PARAMS.GEAR_JERK>100.0 THEN
    GEAR_JERK=DEF_GEAR_JERK
  ELSE
    GEAR_JERK=DEF_GEAR_JERK*PARAMS.GEAR_JERK/100.0
  ENDIF
  
  $GEAR_JERK[1]=GEAR_JERK
  $GEAR_JERK[2]=GEAR_JERK
  $GEAR_JERK[3]=GEAR_JERK
  $GEAR_JERK[4]=GEAR_JERK
  $GEAR_JERK[5]=GEAR_JERK
  $GEAR_JERK[6]=GEAR_JERK
  ;JERK
  IF PARAMS.JERK_FAC>=100.0 THEN
    RET_JERK.CP=$JERK_MA.CP
    RET_JERK.ORI=$JERK_MA.ORI
    RET_JERK.AX=$JERK_MA.AX
    RETURN RET_JERK
  ELSE
    J_F0=0.05
    J_C0=0.50
    J_FACTOR=PARAMS.JERK_FAC/100.0
    IF J_FACTOR<=J_C0 THEN
      J_FACTOR=J_F0/J_C0*J_FACTOR
    ELSE
      J_D3=(J_FACTOR-J_C0)/(1-J_C0)
      J_D3=J_D3*J_D3*J_D3
      J_FACTOR=J_F0/J_C0*J_FACTOR + (J_C0-J_F0)*J_D3/J_C0
    ENDIF
    RET_JERK.CP=$JERK_MA.CP*J_FACTOR
    RET_JERK.ORI=$JERK_MA.ORI*J_FACTOR
    RET_JERK.AX.A1=$JERK_MA.AX.A1*J_FACTOR
    RET_JERK.AX.A2=$JERK_MA.AX.A2*J_FACTOR
    RET_JERK.AX.A3=$JERK_MA.AX.A3*J_FACTOR
    RET_JERK.AX.A4=$JERK_MA.AX.A4*J_FACTOR
    RET_JERK.AX.A5=$JERK_MA.AX.A5*J_FACTOR
    RET_JERK.AX.A6=$JERK_MA.AX.A6*J_FACTOR
    IF $EX_AX_NUM>0 THEN
      RET_JERK.AX.E1=$JERK_MA.AX.E1*J_FACTOR
      RET_JERK.AX.E2=$JERK_MA.AX.E2*J_FACTOR
      RET_JERK.AX.E3=$JERK_MA.AX.E3*J_FACTOR
      RET_JERK.AX.E4=$JERK_MA.AX.E4*J_FACTOR
      RET_JERK.AX.E5=$JERK_MA.AX.E5*J_FACTOR
      RET_JERK.AX.E6=$JERK_MA.AX.E6*J_FACTOR
    ENDIF
    ;return JERK-structure
    RETURN RET_JERK
  ENDIF
ENDFCT

DEF  PTP_DAT ( )
  VEL_PTP (PDAT_ACT.VEL )
  ACC_PTP (PDAT_ACT.ACC )
  $APO.CPTP=PDAT_ACT.APO_DIST
END
DEF  CP_DAT ( )
  VEL_CP (LDAT_ACT.VEL )
  ACC_CP (LDAT_ACT.ACC )
  $APO.CDIS=LDAT_ACT.APO_DIST
END
DEF  LK_BASE (BASE_NO : IN )
  INT MACH_IDX, BASE_NO, COOP_KRC_INDEX
  DECL ESYS MECH_TYPE
     MACH_IDX = MACHINE_FRAME_DAT[BASE_NO].MACH_DEF_INDEX
     IF (MACH_IDX > 0) Then
       MECH_TYPE = MACHINE_DEF[MACH_IDX].MECH_TYPE
       COOP_KRC_INDEX = MACHINE_DEF[MACH_IDX].COOP_KRC_INDEX
     ELSE
       MECH_TYPE = #NONE
       COOP_KRC_INDEX = 0
     ENDIF
     IF (MECH_TYPE == #ROBOT) THEN
       IF (COOP_KRC_INDEX > 1) THEN
          ; Linking to a frame - end-of-arm tool
          $BASE=LK(MACHINE_DEF[MACH_IDX].ROOT, $COOP_KRC[MACHINE_DEF[MACH_IDX].COOP_KRC_INDEX].IP_ADDR[], BASE_DATA[BASE_NO], MACHINE_DEF[MACH_IDX].MECH_TYPE)
       ELSE
         IF (COOP_KRC_INDEX == 1) THEN
           $BASE=BASE_DATA[BASE_NO]
         ENDIF
       ENDIF
     ELSE
       IF (MECH_TYPE == #NONE) THEN
         IF (BASE_NO <= MAX_BASE) THEN
           $BASE=BASE_DATA[BASE_NO]
         ENDIF
       ELSE
         ; The base is relative to an external axis - need to determine if it is a local
         ; external axis or a remote one and call EK/LK appropriately.  A COOP_KRC_INDEX
         ; of 1 signifies it is a local external axis.
         IF (MECH_TYPE == #CONVEYOR) THEN
           ;EB_BASE()
         ELSE
           IF (COOP_KRC_INDEX == 1) THEN
             EX_BASE(BASE_NO)
           ELSE
             $BASE=LK(MACHINE_DEF[MACH_IDX].ROOT, $COOP_KRC[MACHINE_DEF[MACH_IDX].COOP_KRC_INDEX].IP_ADDR[], BASE_DATA[BASE_NO], MACHINE_DEF[MACH_IDX].MECH_TYPE)
           ENDIF
         ENDIF
       ENDIF
     ENDIF
  CONTINUE
  $ACT_EX_AX=-1
  CONTINUE
  $ACT_BASE=BASE_NO
END

DEFFCT FRAME LK_SBASE (BASE_NO : IN )
  INT MACH_IDX, BASE_NO, COOP_KRC_INDEX
  FRAME RET_BASE
  DECL ESYS MECH_TYPE
     MACH_IDX = MACHINE_FRAME_DAT[BASE_NO].MACH_DEF_INDEX
     IF (MACH_IDX > 0) Then
       MECH_TYPE = MACHINE_DEF[MACH_IDX].MECH_TYPE
       COOP_KRC_INDEX = MACHINE_DEF[MACH_IDX].COOP_KRC_INDEX
     ELSE
       MECH_TYPE = #NONE
       COOP_KRC_INDEX = 0
     ENDIF
     IF (MECH_TYPE == #ROBOT) THEN
       IF (COOP_KRC_INDEX > 1) THEN
          ; Linking to a frame - end-of-arm tool
          RET_BASE=LK(MACHINE_DEF[MACH_IDX].ROOT, $COOP_KRC[MACHINE_DEF[MACH_IDX].COOP_KRC_INDEX].IP_ADDR[], BASE_DATA[BASE_NO], MACHINE_DEF[MACH_IDX].MECH_TYPE)
       ELSE
         IF (COOP_KRC_INDEX == 1) THEN
           RET_BASE=BASE_DATA[BASE_NO]
         ENDIF
       ENDIF
     ELSE
       IF (MECH_TYPE == #NONE) THEN
         IF (BASE_NO <= MAX_BASE) THEN
           RET_BASE=BASE_DATA[BASE_NO]
         ENDIF
       ELSE
         ; The base is relative to an external axis - need to determine if it is a local
         ; external axis or a remote one and call EK/LK appropriately.  A COOP_KRC_INDEX
         ; of 1 signifies it is a local external axis.
         IF (MECH_TYPE == #CONVEYOR) THEN
           ;EB_SBASE()
         ELSE
           IF (COOP_KRC_INDEX == 1) THEN
             RET_BASE = EX_SBASE(BASE_NO)
           ELSE
             RET_BASE=LK(MACHINE_DEF[MACH_IDX].ROOT, $COOP_KRC[MACHINE_DEF[MACH_IDX].COOP_KRC_INDEX].IP_ADDR[], BASE_DATA[BASE_NO], MACHINE_DEF[MACH_IDX].MECH_TYPE)
           ENDIF
         ENDIF
       ENDIF
     ENDIF
  ;CONTINUE
  ;$ACT_EX_AX=-1
  ;CONTINUE
  $ACT_BASE=BASE_NO
  RETURN RET_BASE
ENDFCT

GLOBAL DEF MsgNotify(sText[]:IN, sModul[]:IN, nNumPar:IN, sTextPar[]:IN, nMsgNr:IN)
;************************************************************
;Function: Executes a Message Send of the notify message
;************************************************************
Decl CHAR sText[], sModul[], sTextPar[]   
Decl KrlMsg_T Msg
Decl EKrlMsgType MsgType
Decl KrlMsgPar_T MsgPar[3]
Decl KrlMsgOpt_T MsgOpt
Decl State_T State
Decl Int count, len, offset, nNumPar, nHandle, nMsgNr

MsgType=#Notify
Msg.Nr=1
Err_Clear($Err)
On_Error_Proceed
Msg.Nr=nMsgNr
len=Strlen(sText[])
if len>0 then
  if len>80 then
    len=80
  endif
  for count=1 to len
    Msg.Msg_txt[count]=sText[count]
  endfor
else
  Msg.Msg_txt[]="parameter sText[] is missing"
endif
len=Strlen(sModul[])
if len>0 then
  if len>24 then
    len=24
  endif
  for count=1 to len
    Msg.Modul[count]=sModul[count]
  endfor
else
  Msg.Modul[]="Appl" 
endif
Err_Clear($Err)
On_Error_Proceed
offset=nNumPar
if $Err.Number==0 then
  offset=0
  MsgPar[1].Par_Txt[]=" "
  SWRITE(MsgPar[1].Par_Txt[], State, offset, "%d", nNumPar)
  MsgPar[1].Par_type=#Value
else
  Err_Clear($Err)
  On_Error_Proceed
  len=Strlen(sTextPar[])
  if len>0 then
    if len>26 then
      len=26
    endif
    for count=1 to len
      MsgPar[1].Par_Txt[count]=sTextPar[count]
    endfor
    MsgPar[1].Par_type=#Value 
  endif
endif
MsgOpt={ VL_Stop True, Clear_P_Reset True, Log_To_DB False }
nHandle=Set_KrlMsg (MsgType, Msg, MsgPar[], MsgOpt)
END 

GLOBAL DEF MsgNotifyLogToDB(sText[]:IN, sModul[]:IN, nNumPar:IN, sTextPar[]:IN, nMsgNr:IN)
;********************************************************************************
;Function: Executes a Message Send of the notify message with logging in DB
;********************************************************************************
Decl CHAR sText[], sModul[], sTextPar[]   
Decl KrlMsg_T Msg
Decl EKrlMsgType MsgType
Decl KrlMsgPar_T MsgPar[3]
Decl KrlMsgOpt_T MsgOpt
Decl State_T State
Decl Int count, len, offset, nNumPar, nHandle, nMsgNr

MsgType=#Notify
Msg.Nr=1
Err_Clear($Err)
On_Error_Proceed
Msg.Nr=nMsgNr
len=Strlen(sText[])
if len>0 then
  if len>80 then
    len=80
  endif
  for count=1 to len
    Msg.Msg_txt[count]=sText[count]
  endfor
else
  Msg.Msg_txt[]="parameter sText[] is missing"
endif
len=Strlen(sModul[])
if len>0 then
  if len>24 then
    len=24
  endif
  for count=1 to len
    Msg.Modul[count]=sModul[count]
  endfor
else
  Msg.Modul[]="Appl" 
endif
Err_Clear($Err)
On_Error_Proceed
offset=nNumPar
if $Err.Number==0 then
  offset=0
  MsgPar[1].Par_Txt[]=" "
  SWRITE(MsgPar[1].Par_Txt[], State, offset, "%d", nNumPar)
  MsgPar[1].Par_type=#Value
else
  Err_Clear($Err)
  On_Error_Proceed
  len=Strlen(sTextPar[])
  if len>0 then
    if len>26 then
      len=26
    endif
    for count=1 to len
      MsgPar[1].Par_Txt[count]=sTextPar[count]
    endfor
    MsgPar[1].Par_type=#Value 
  endif
endif
MsgOpt={ VL_Stop True, Clear_P_Reset True, Log_To_DB True }
nHandle=Set_KrlMsg (MsgType, Msg, MsgPar[], MsgOpt)
END 

GLOBAL DEF MsgQuit(sText[]:IN, sModul[]:IN, nNumPar:IN, sTextPar[]:IN, nMsgNr:IN)
;************************************************************
;Function: Executes a Message Send of the quit message
;************************************************************
Decl CHAR sText[], sModul[], sTextPar[]  
Decl KrlMsg_T Msg
Decl EKrlMsgType MsgType
Decl KrlMsgPar_T MsgPar[3]
Decl KrlMsgOpt_T MsgOpt
Decl State_T State
Decl Int count, len, offset, nNumPar, nHandle, nMsgNr

MsgType=#Quit
Msg.Nr=1
Err_Clear($Err)
On_Error_Proceed
Msg.Nr=nMsgNr
len=Strlen(sText[])
if len>0 then
  if len>80 then
    len=80
  endif
  for count=1 to len
    Msg.Msg_txt[count]=sText[count]
  endfor
else
  Msg.Msg_txt[]="parameter sText[] is missing"
endif
len=Strlen(sModul[])
if len>0 then
  if len>24 then
    len=24
  endif
  for count=1 to len
    Msg.Modul[count]=sModul[count]
  endfor
else
  Msg.Modul[]="Appl" 
endif
Err_Clear($Err)
On_Error_Proceed
offset=nNumPar
if $Err.Number==0 then
  offset=0
  MsgPar[1].Par_Txt[]=" "
  SWRITE(MsgPar[1].Par_Txt[], State, offset, "%d", nNumPar)
  MsgPar[1].Par_type=#Value
else
  Err_Clear($Err)
  len=Strlen(sTextPar[])
  if len>0 then
    if len>26 then
      len=26
    endif
    for count=1 to len
      MsgPar[1].Par_Txt[count]=sTextPar[count]
    endfor
    MsgPar[1].Par_type=#Value 
  endif
endif
MsgOpt={ VL_Stop True, Clear_P_Reset True, Log_To_DB False }
nHandle=Set_KrlMsg (MsgType, Msg, MsgPar[], MsgOpt)
while ( Exists_KrlMsg(nHandle) ) 
  wait sec 0.1
endwhile
END 

GLOBAL DEF MsgState(nHandle:OUT, sText[]:IN, sModul[]:IN, nNumPar:IN, sTextPar[]:IN, nMsgNr:IN)
;************************************************************
;Function: Executes a Message Send of the state message
;************************************************************
Decl CHAR sText[], sModul[], sTextPar[]  
Decl KrlMsg_T Msg
Decl EKrlMsgType MsgType
Decl KrlMsgPar_T MsgPar[3]
Decl KrlMsgOpt_T MsgOpt
Decl State_T State
Decl Int count, len, offset, nNumPar, nHandle, nMsgNr

MsgType=#State
Msg.Nr=1
Err_Clear($Err)
On_Error_Proceed
Msg.Nr=nMsgNr
len=Strlen(sText[])
if len>0 then
  if len>80 then
    len=80
  endif
  for count=1 to len
    Msg.Msg_txt[count]=sText[count]
  endfor
else
  Msg.Msg_txt[]="parameter sText[] is missing"
endif
len=Strlen(sModul[])
if len>0 then
  if len>24 then
    len=24
  endif
  for count=1 to len
    Msg.Modul[count]=sModul[count]
  endfor
else
  Msg.Modul[]="Appl" 
endif
Err_Clear($Err)
On_Error_Proceed
offset=nNumPar
if $Err.Number==0 then
  offset=0
  MsgPar[1].Par_Txt[]=" "
  SWRITE(MsgPar[1].Par_Txt[], State, offset, "%d", nNumPar)
  MsgPar[1].Par_type=#Value
else
  Err_Clear($Err)
  len=Strlen(sTextPar[])
  if len>0 then
    if len>26 then
      len=26
    endif
    for count=1 to len
      MsgPar[1].Par_Txt[count]=sTextPar[count]
    endfor
    MsgPar[1].Par_type=#Value 
  endif
endif
MsgOpt={ VL_Stop True, Clear_P_Reset True, Log_To_DB False }
nHandle=Set_KrlMsg (MsgType, Msg, MsgPar[], MsgOpt)
END 

GLOBAL DEF MsgLoop(sText[]:IN,sModul[]:IN)
;************************************************************
;Function: Executes a Message Send of the loop message
;************************************************************
Decl CHAR sText[], sModul[]
Decl CHAR sMsg[80]
Decl CHAR sMod[24]
Decl Int count,len

len=Strlen(sText[])
if len>0 then
  if len>80 then
    len=80
  endif
  for count=1 to len
    sMsg[count]=sText[count]
  endfor
endif
len=Strlen(sModul[])
if len>0 then
  if len>24 then
    len=24
  endif
  for count=1 to len
    sMod[count]=sModul[count]
  endfor
else
  sMod[]="Appl" 
endif
if (Strlen(sMsg[])>0) then
  if lnHandle>0 then
    wait for Clear_KrlMsg (lnHandle) OR TRUE
    lnHandle=0
  endif
  for count=1 to Strlen(sMsg[])
    if sMsg[count]<>" " then
      MsgState(lnHandle, sMsg[], sMod[])
	  EXIT
    endif
  endfor  
endif
END 

GLOBAL DEF MsgDialog(nAnswer:OUT,sText[]:IN,sModul[]:IN,sTextPar[]:IN,sDialogSK1[]:IN,sDialogSK2[]:IN,sDialogSK3[]:IN,sDialogSK4[]:IN,sDialogSK5[]:IN,sDialogSK6[]:IN,sDialogSK7[]:IN,NoBrakes:IN, nMsgNr:IN)
;************************************************************
;Function: Executes a dialog
;parameter NoBrakes causes the robot to leave brakes open
;************************************************************
Decl KrlMsg_T Msg
Decl KrlMsgPar_T MsgPar[3]
Decl KrlMsgOpt_T MsgOpt
DECL KrlMsgDlgSK_T Msg_SOFTKEY[7]
Decl Int count, len, nHandle, nAnswer, nMsgNr
Decl BOOL NoBrakes

Decl CHAR sText[], sModul[], sTextPar[], sDialogSK1[], sDialogSK2[], sDialogSK3[], sDialogSK4[], sDialogSK5[], sDialogSK6[], sDialogSK7[]

Msg.Nr=1
Err_Clear($Err)
On_Error_Proceed
Msg.Nr=nMsgNr
len=Strlen(sText[])
if len>0 then
  if len>80 then
    len=80
  endif
  for count=1 to len
    Msg.Msg_txt[count]=sText[count]
  endfor
else
  Msg.Msg_txt[]="parameter sText[] is missing"
endif
len=Strlen(sModul[])
if len>0 then
  if len>24 then
    len=24
  endif
  for count=1 to len
    Msg.Modul[count]=sModul[count]
  endfor
else
  Msg.Modul[]="Appl" 
endif

Err_Clear($Err)
On_Error_Proceed
len=Strlen(sDialogSK1[])
if $Err.Number==0 then
  if len > 0 then
    if len>24 then
      len=24
    endif
    Msg_SOFTKEY[7].Sk_Type = #KEY
    for count=1 to len
      Msg_SOFTKEY[7].Sk_txt[count] = sDialogSK1[count]
    endfor
  endif
else
    for count=1 to 24
      Msg_SOFTKEY[7].Sk_txt[count] = " "
    endfor
endif
Err_Clear($Err)
On_Error_Proceed
len=Strlen(sDialogSK2[])
if $Err.Number==0 then
  len=Strlen(sDialogSK2[])
  if len > 0 then
    if len>24 then
      len=24
    endif
    Msg_SOFTKEY[6].Sk_Type = #KEY
    for count=1 to len
      Msg_SOFTKEY[6].Sk_txt[count] = sDialogSK2[count]
    endfor
  endif
else
    for count=1 to 24
      Msg_SOFTKEY[6].Sk_txt[count] = " "
    endfor
endif
Err_Clear($Err)
On_Error_Proceed
len=Strlen(sDialogSK3[])
if $Err.Number==0 then
  len=Strlen(sDialogSK3[])
  if len > 0 then
    if len>24 then
      len=24
    endif
    Msg_SOFTKEY[5].Sk_Type = #KEY
    for count=1 to len
      Msg_SOFTKEY[5].Sk_txt[count] = sDialogSK3[count]
    endfor
  endif
else
    for count=1 to 24
      Msg_SOFTKEY[5].Sk_txt[count] = " "
    endfor
endif
Err_Clear($Err)
On_Error_Proceed
len=Strlen(sDialogSK4[])
if $Err.Number==0 then
  len=Strlen(sDialogSK4[])
  if len > 0 then
    if len>24 then
      len=24
    endif
    Msg_SOFTKEY[4].Sk_Type = #KEY
    for count=1 to len
      Msg_SOFTKEY[4].Sk_txt[count] = sDialogSK4[count]
    endfor
  endif
else
    for count=1 to 24
      Msg_SOFTKEY[4].Sk_txt[count] = " "
    endfor
endif
Err_Clear($Err)
On_Error_Proceed
len=Strlen(sDialogSK5[])
if $Err.Number==0 then
  len=Strlen(sDialogSK5[])
  if len > 0 then
    if len>24 then
      len=24
    endif
    Msg_SOFTKEY[3].Sk_Type = #KEY
    for count=1 to len
      Msg_SOFTKEY[3].Sk_txt[count] = sDialogSK5[count]
    endfor
  endif
else
    for count=1 to 24
      Msg_SOFTKEY[3].Sk_txt[count] = " "
    endfor
endif
Err_Clear($Err)
On_Error_Proceed
len=Strlen(sDialogSK6[])
if $Err.Number==0 then
  len=Strlen(sDialogSK6[])
  if len > 0 then
    if len>24 then
      len=24
    endif
    Msg_SOFTKEY[2].Sk_Type = #KEY
    for count=1 to len
      Msg_SOFTKEY[2].Sk_txt[count] = sDialogSK6[count]
    endfor
  endif
else
    for count=1 to 24
      Msg_SOFTKEY[2].Sk_txt[count] = " "
    endfor
endif
Err_Clear($Err)
On_Error_Proceed
len=Strlen(sDialogSK7[])
if $Err.Number==0 then
  len=Strlen(sDialogSK7[])
  if len > 0 then
    if len>24 then
      len=24
    endif
    Msg_SOFTKEY[1].Sk_Type = #KEY
    for count=1 to len
      Msg_SOFTKEY[1].Sk_txt[count] = sDialogSK7[count]
    endfor
  endif
else
    for count=1 to 24
      Msg_SOFTKEY[1].Sk_txt[count] = " "
    endfor
endif
len=Strlen(sTextPar[])
if len>0 then
  if len>26 then
    len=26
  endif
  for count=1 to len
    MsgPar[1].Par_Txt[count]=sTextPar[count]
  endfor
  MsgPar[1].Par_type=#Value 
endif
  
MsgOpt={ VL_Stop True, Clear_P_Reset True, Log_To_DB False }
  
nHandle=SET_KRLDLG(Msg, MsgPar[], Msg_SOFTKEY[], MsgOpt)

Err_Clear($Err)
On_Error_Proceed
NoBrakes=NoBrakes
if NOT($Err.Number==0) then
  NoBrakes=FALSE
endif
If (nHandle > 0) Then
   WHILE (Exists_KrlDlg(nHandle, nAnswer))
      WAIT SEC 0.5
      if NoBrakes then
        PTP $AXIS_ACT
      endif
   ENDWHILE
endif
END

GLOBAL DEF MsgNotifyTextPar(sText[]:IN, sModul[]:IN, nNumPar:IN, sTextPar[]:IN, sTextPar2[]:IN, nMsgNr:IN)
;************************************************************
;Function: Executes a Message Send of the notify message with text parameter
;************************************************************
Decl CHAR sText[], sModul[], sTextPar[], sTextPar2[]
Decl KrlMsg_T Msg
Decl EKrlMsgType MsgType
Decl KrlMsgPar_T MsgPar[3]
Decl KrlMsgOpt_T MsgOpt
Decl State_T State
Decl Int count, len, offset, nNumPar, nHandle, nMsgNr

MsgType=#Notify
Msg.Nr=1
Err_Clear($Err)
On_Error_Proceed
Msg.Nr=nMsgNr
len=Strlen(sText[])
if len>0 then
  if len>80 then
    len=80
  endif
  for count=1 to len
    Msg.Msg_txt[count]=sText[count]
  endfor
else
  Msg.Msg_txt[]="parameter sText[] is missing"
endif
len=Strlen(sModul[])
if len>0 then
  if len>24 then
    len=24
  endif
  for count=1 to len
    Msg.Modul[count]=sModul[count]
  endfor
else
  Msg.Modul[]="Appl" 
endif
offset=nNumPar
if nNumPar==0 then
   ; uebergebener Parameter 1
   len=Strlen(sTextPar[])
   if len>0 then
      if len>26 then
         len=26
      endif
      for count=1 to len
         MsgPar[1].Par_Txt[count]=sTextPar[count]
      endfor
      MsgPar[1].Par_type=#Value 
   endif  
   ; uebergebener Parameter 2
   len=Strlen(sTextPar2[])
   if len>0 then
      if len>26 then
         len=26
      endif
      for count=1 to len
         MsgPar[2].Par_Txt[count]=sTextPar2[count]
      endfor
      MsgPar[2].Par_type=#Value 
   endif  
else
   offset=0
   MsgPar[1].Par_Txt[]=" "
   SWRITE(MsgPar[1].Par_Txt[], State, offset, "%d", nNumPar)
   MsgPar[1].Par_type=#Value
endif
MsgOpt={ VL_Stop True, Clear_P_Reset True, Log_To_DB False }
nHandle=Set_KrlMsg (MsgType, Msg, MsgPar[], MsgOpt)
END 