&ACCESS RV
&PARAM TPVW_VERSION=8.3.18
&PARAM SUPPRESS = UnusedProgram
DEF VW_Safety()
END
;FOLD ;%{H} %MKUKATPVW
GLOBAL DEF BrakeTestReq()
INT Ret,IntArray[5]
REAL RealArray[1]
;pruefe ob roboterinterpreter programm aktiv ist und intializiere bremsentest falls Anforderung anliegt
if ((Varstate("$pro_ip.si01.name[]")==#INITIALIZED) OR (Varstate("$prog_info[1].pro_ip_name[]")==#INITIALIZED)) then
	if ($braketest_req_int or $braketest_req_ex) then
		MD_SETSTATE(brakeTestDevName[], #INITIALIZED)
	endif
endif
;------------------------------------
BAS (#INITMOV,0 )
IF ($mode_op==#t1) THEN
;wenn T1, dann fragen ob parkposition erforderlich ist
;-------- park position request ------
   ParkPositionRequest()
   IF(FlagNo_GoToPark >0) THEN 
      IF $Flag[FlagNo_GoToPark] == TRUE THEN
         RETURN
      ELSE
         $Flag[FlagNo_GoToPark] = FALSE
      ENDIF
   ENDIF
;-------------------------------------
ENDIF
;wenn keine Anforderung anliegt, geht zurueck
if NOT ($braketest_req_int or $braketest_req_ex) then
	RETURN
endif
;bremsentest starten wenn anforderung anliegt
;------------ start Brake Test, set Flag-------------
IF (FlagNo_RunBrkTest>0) Then
   $Flag[FlagNo_RunBrkTest]=TRUE
ELSE
   IF NOT(UpNo_ToBrkTestPath >0) THEN
      MsgNotify("RunBraketestFlagNotSet", "BrkTst",,,113)
   ENDIF
ENDIF
;wenn Flag nicht konfiguriert aber UP konfiguriert ist, bremsentest ueber UP aufrufen
IF(NOT(FlagNo_RunBrkTest>0) AND (UpNo_ToBrkTestPath >0) AND ($braketest_req_int or $braketest_req_ex)) THEN
	SEL_RES=SELECT(#UP,UpNo_ToBrkTestPath,TRUE); zum Bremsentest fahren
ENDIF

END

GLOBAL DEF BrakeTestRun()
DECL E6AXIS BtStPos
INT Idx, i, Ret, IntArray[5]
INT BitfieldAxesInTest
REAL RealArray[1]
BOOL B_Park

; init Flag 
B_Park=FALSE
repeat
  repeat
    Ret = MD_CMD(brakeTestDevName[], "START_TEST", IntArray[], RealArray[])
  until ($mode_op<>#t1)
  Ret = MD_CMD(brakeTestDevName[], "START_TEST", IntArray[], RealArray[])
   IF(FlagNo_RunBrkTest >0) THEN
      IF ( Ret <> 0) then
         ; Entweder (Ret == +1) - dann liegt keine Testanforderung vor - oder
         ; (Ret < 0) - dann wurde bereits eine Zustandsmeldung vom Treiber abgesetzt
         $Flag[FlagNo_RunBrkTest]=FALSE
         RETURN
      ELSE
         $Flag[FlagNo_RunBrkTest]=TRUE
      ENDIF
   ELSE
      IF ( Ret <> 0) then
         ; Entweder (Ret == +1) - dann liegt keine Testanforderung vor - oder
         ; (Ret < 0) - dann wurde bereits eine Zustandsmeldung vom Treiber abgesetzt
         RETURN
      ENDIF         
   ENDIF
  ; Die Achsmasken aus der INI-Datei auslesen
  BitfieldAxesInTest = IntArray[1]

  BtStPos=$AXIS_ACT
 
  i=1
  FOR Idx = 1 TO 12
   if (( BitfieldAxesInTest b_and i) == i ) AND (B_Park == FALSE) then
     if (Idx==5) AND $PAL_MODE AND NOT $DEF_A5LINK AND $DEF_A4FIX then
       $PAL_MODE=FALSE
     endif
     repeat 
     TestAxis(Idx)
     PTP BtStPos
     until GetResult() 

     IF (FlagNo_GoToPark > 0) THEN
         B_Park = $FLAG[FlagNo_GoToPark]   
     ENDIF 
     if (Idx==5) AND NOT $PAL_MODE AND NOT $DEF_A5LINK AND $DEF_A4FIX then
       $PAL_MODE=TRUE
     endif
   endif
   i=i*2 
  ENDFOR
  WAIT FOR TRUE
  Ret = MD_CMD(brakeTestDevName[], "END_TEST", IntArray[], RealArray[])
until (( Ret == 0 ) OR (B_Park == TRUE )) 

IF (FlagNo_RunBrkTest>0) THEN
  IF ( Ret == 0) THEN
        $Flag[FlagNo_RunBrkTest]=FALSE
  ENDIF
ENDIF
END

DEF TestAxis(AxisNr: IN)
INT AxisNr
INT Ret, NrFlag
INT IntArray[3]
REAL RealArray[1]
AxNr=AxisNr
IntArray[1] = AxisNr
Ret = MD_CMD(brakeTestDevName[], "SELECT_TARGET", IntArray[], RealArray[])
NrFlag=IntArray[1]
BtIrNr=IntArray[3]
$FLAG[NrFlag]=FALSE
IF(AxNr<7) THEN
$VEL_AXIS[AxNr]=IntArray[2]
ELSE
$VEL_EXTAX[AxNr-6]=IntArray[2]
ENDIF
INTERRUPT DECL BtIrNr WHEN $FLAG[NrFlag] DO Decelerate()
INTERRUPT ON BtIrNr
MoveAxis(AxisNr)
END


DEF MoveAxis(AxisNr: IN)
INT Ret, AxisNr
INT IntArray[5]
REAL RealArray[6]
E6AXIS AxisRel
$ADVANCE=0
Ret = MD_CMD(brakeTestDevName[], "GET_ROB_ANGLES", IntArray[], RealArray[])
AxisRel.A1=RealArray[1]
AxisRel.A2=RealArray[2]
AxisRel.A3=RealArray[3]
AxisRel.A4=RealArray[4]
AxisRel.A5=RealArray[5]
AxisRel.A6=RealArray[6]
Ret = MD_CMD(brakeTestDevName[], "GET_EXT_ANGLES", IntArray[], RealArray[])
AxisRel.E1=RealArray[1]
AxisRel.E2=RealArray[2]
AxisRel.E3=RealArray[3]
AxisRel.E4=RealArray[4]
AxisRel.E5=RealArray[5]
AxisRel.E6=RealArray[6]
PTP $AXIS_ACT
Ret = MD_CMD(brakeTestDevName[], "TRIGGER_TEST_RUN", IntArray[], RealArray[])
PTP_REL AxisRel
WAIT FOR TRUE
; Hier kommt man nur hin, wenn die Bewegung zu Ende gefahren wurde.
; Im Gutfall wird aber ein BRAKE / RESUME ausgeführt und damit diese Funktion verlassen
MsgQuit("BT_MAX_AXIS_MOVE", "BrkTst",AxisNr,,111)
END

DEF Decelerate()
INT ret
INT IntArray[5]
REAL RealArray[6]
INTERRUPT OFF BtIrNr
BRAKE
ret = MD_CMD(brakeTestDevName[], "FINISH_TEST_RUN", IntArray[], RealArray[])
if ret <> 0 then
  MsgNotify("FINISH_TEST_RUN returns %1 ", "BrkTst", ret,,110)
endif
RESUME
END

DEFFCT BOOL GetResult()
INT ret
INT IntArray[5]
REAL RealArray[1]
Decl CHAR DialogText[20]
DECL CHAR AxNrText[10]

IF (FlagNo_GoToPark > 0)THEN 
   $Flag[FlagNo_GoToPark] = FALSE
ENDIF

ret=MD_CMD(brakeTestDevName[], "GET_RESULT", IntArray[], RealArray[])
SWITCH IntArray[1]
 CASE 0
  ; BT_BRAKE_OK
  Return TRUE
 CASE 1
  ; BT_BRAKE_WEAK
  Return TRUE
 CASE 2
  ;BT_BRAKE_NOT_OK
  DialogText[] = "BT_BRAKE_NOT_OK"
 CASE 3
  ; BT_NO_BRAKING
  DialogText[] = "BT_BRAKE_NOT_OK"
  IntArray[1]=2
 CASE 4
  ; BT_MOTION_FAULT
  DialogText[] = "BT_EVALUATION_FAILED"
 CASE 5
  ; BT_INCOMPLETE
  DialogText[] = "BT_INCOMPLETE"
 CASE 6
  ; BT_REPEAT
  Return FALSE
ENDSWITCH

IF(IntArray[2]<7) THEN
  AxNrText[]="A "
  AxNrText[2]=IntArray[2]+48
ELSE
  AxNrText[]="E "
  AxNrText[2]=IntArray[2]+42
ENDIF

MsgDialog(ret, DialogText[], "BrkTst", AxNrText[], "TryAgain", "GoToPark",,,,,,TRUE,100+IntArray[1])

if ret==7 then
  ; Rückgabewert 7 = Softkey "TryAgain" ganz rechts
  ; Testlauf wiederholen
  Return FALSE
endif

;goto parkposition

IF (FlagNo_GoToPark > 0)THEN 
   IF (ret == 6) THEN
      $Flag[FlagNo_GoToPark] = TRUE
      RETURN TRUE
   ENDIF
ENDIF
IF (UpNo_ToBrkTestPark>0) THEN
  SEL_RES=SELECT(#UP,UpNo_ToBrkTestPark,TRUE) ;zurückfahren vom Bremsentest
ENDIF
WAIT FOR TRUE
ParkPosReached()
Return FALSE
ENDFCT

GLOBAL DEF ParkPosReached()
INT Ret
INT IntArray[5]
REAL RealArray[1]
  Ret = MD_CMD(brakeTestDevName[], "SIGNAL_PARK_POS", IntArray[], RealArray[])

  repeat
    MsgNotify("ParkPositionReached", "BrkTst",,,100)
    halt
  until false  
END

GLOBAL DEF MasRefReq()

  IF FlagNo_GoToMasRefTest > 0 THEN
    IF NOT $MasteringTest_Req_Ext AND NOT $MasteringTest_Req_Int THEN
        $Flag[FlagNo_GoToMasRefTest] = FALSE
        RETURN
    ELSE
        $Flag[FlagNo_GoToMasRefTest] = TRUE
    ENDIF
  ELSE
    IF NOT $MasteringTest_Req_Ext AND NOT $MasteringTest_Req_Int THEN
      RETURN
    ENDIF
  ENDIF

  MasRefBefore()
  
  IF FlagNo_GoToMasRefTest > 0 THEN
	RETURN
  ENDIF
  SEL_RES=SELECT(#UP,UpNo_ToMasRefPath,TRUE)
  MasRefEnd()
END

GLOBAL DEF MasRefBefore(nGroup:IN)
DECL INT nGroup, mGroup
  $MasteringTest_Active = FALSE 
  WHILE NOT $MasteringTest_Switch_OK
    MsgQuit("MasterReferenceSwitchFailure", "MasRef",,,100)
  ENDWHILE
  Err_Clear($Err)
  On_Error_Proceed
  mGroup = nGroup
  IF NOT($Err.Number==0) THEN
    $MasteringTest_Group = 0
  ELSE
    MasRefGroup(nGroup)
  ENDIF

  $MasteringTest_Active = FALSE
  REPEAT
    $MasteringTest_Active = TRUE
    WAIT SEC 0.2
    
    IF NOT $MasteringTest_Active THEN
        MsgQuit("MasterReferenceNotActivated", "MasRef",,,101)
    ENDIF
  UNTIL $MasteringTest_Active

END

GLOBAL DEF MasRefEnd()
  IF NOT($MasteringTest_Group==0) then
    $MasteringTest_Group = 0
    WAIT SEC 0.2
  ENDIF
  $MasteringTest_Active = FALSE

  nLapsedTime = 0
  REPEAT
    WAIT SEC 0.096
    nLapsedTime = nLapsedTime + 1
  UNTIL (NOT $MasteringTest_Active AND NOT $MasteringTest_Req_Int) or (nLapsedTime > nLapsedTimeout)

  IF $MasteringTest_Active THEN

  MsgQuit("MasterReferenceNotActivated", "MasRef",,,102)
  ENDIF
  
 IF FlagNo_GoToMasRefTest > 0 THEN
  IF NOT $MasteringTest_Req_Ext AND NOT $MasteringTest_Req_Int THEN
        $Flag[FlagNo_GoToMasRefTest] = FALSE
  ENDIF
 ENDIF
END

GLOBAL DEF MasRefGroup(Group :IN)
DECL INT Group, mGroup
  WAIT SEC 0.6
  Err_Clear($Err)
  On_Error_Proceed
  mGroup = Group
  IF NOT($Err.Number==0) then
    MsgQuit("GroupNumberMissing", "MasRef",,,103)
    Return
  ELSE
    IF (Group>3) then
        MsgQuit("GroupNumberGreaterThan3", "MasRef",,,104)
        Return
    ENDIF
    IF (Group<0) then
        MsgQuit("GroupNumberLessThan1", "MasRef",,,105)
        Return
    ENDIF
    $MasteringTest_Group = Group
    WAIT SEC 0.2
  ENDIF
END

GLOBAL DEF ParkPositionRequest() 
int dlgAnswer
   MsgDialog(dlgAnswer, "DlgTextGoToParkPosition", "BrkTst", " ","DAnswerNo",,,,,,"DAnswerYes",,120)
   ;setze Flag wenn konfiguriert ist
   IF ((dlgAnswer == 1) AND (FlagNo_GoToPark > 0)) THEN  
      $Flag[FlagNo_GoToPark] = TRUE
      RETURN
   ENDIF
   ;rufe Up auf, wenn Up konfiguriert ist
   IF ((dlgAnswer == 1) AND (UpNo_ToBrkTestPark > 0)) THEN  
      SEL_RES=SELECT(#UP,UpNo_ToBrkTestPark,TRUE)
      RETURN
   ENDIF
   ;wenn keine konfiguration anliegt bringt meldung
   IF NOT(FlagNo_GoToPark>0) AND NOT(UpNo_ToBrkTestPark >0) THEN
     MsgNotify("ParkPositionFlagNotSet", "BrkTst",,,112)
   ELSE
      IF(FlagNo_GoToPark>0) THEN
         $Flag[FlagNo_GoToPark] = FALSE
      ENDIF
   ENDIF
END
;ENDFOLD 


