&ACCESS  R
&PARAM DISKPATH = System
&PARAM TPVW_VERSION = 8.3.18
&PARAM SUPPRESS = LoosOfPrecision UnusedProgram AssignmentLoosesPrecisi
DEF  VW (COMMAND :IN,COND :IN,P1 :IN,P2 :IN,P3 :IN,P4 :IN,B1 :IN, POINT :IN )
   ; FOLD ;%{H} %MKUKATPVW
   ; standard routines VW-tech package
   DECL VW_COMMAND COMMAND
   BOOL COND
   REAL P1,P2,P3,P4
   BOOL B1
   DECL E6POS POINT
   IF  NOT COND THEN
      GOTO PEXIT
   ENDIF
   SWITCH  COMMAND
   CASE #VW_PULSE
      VW_PULSE (P1,P2,P3,P4,B1)
   CASE #VW_INIT
	; MUE 18.10.2006 
      LIN_SUCHEN_OVRED=-1
;AVO
VW_Suchl_A_Fehler = 0
VW_Suchl_F_Fehler = 0
VW_Suchl_Max_Weg= 0.0
VW_Suchl_Max_Weg_T1= 0.0
VW_Suchl_Dist_M = 0.0
VW_Suchl_Ziel_Dist = 100.0
;AVO Ende
      $CYCFLAG[255]=TRUE
      $CYCFLAG[254]=$CYCFLAG[255]
      TRIGGER  WHEN DISTANCE=1 DELAY=-0.05 DO $OUT[PF0]=TRUE
      WEAVE_INIT ( )
      VW_USER (#USR_INIT )
      INIT_PROG ( )
   CASE #VW_INIT_UP
      IF  NOT CALLBYSELECT THEN
         INT10=FALSE
;AVO
VW_Suchl_A_Fehler = 0
VW_Suchl_F_Fehler = 0
VW_Suchl_Max_Weg= 0.0
VW_Suchl_Max_Weg_T1= 0.0
;AVO Ende
         $CYCFLAG[255]=TRUE
         $CYCFLAG[254]=$CYCFLAG[255]
         $LOOP_MSG[]="                                                                                                                                "
         VW_USER (#USR_INIT )
         BAS (#INITMOVEUP )
         WEAVE_INIT ( )
         INT10=TRUE
      ENDIF
   CASE #BINOUT
      BINOUT (P1,P2 ) ; interface#, output value
   CASE #B_OUTVPROP
      BINOUTVPROP (P1,P2,P3,P4 ) ; interface#, output value
   CASE #ANAOUT
      ANAOUT (P1,P2,P3,P4 ) ; output mode, interface#, output factor, output offset
   CASE #GUN
      GUN (P1,P2 ) ; gun#, open/close
   CASE #COUNTER
      COUNTER (P1,P2 ) ; counter#, value
   CASE #SET_TIME
      SET_TIMER (P1,P2,P3 ) ; timer#, timer stop/start, start value
   CASE #MPARA
      MPARA ( )
   CASE #FB_CHECK
      FB_CHECK ( )
   CASE #FB_STOP
      FB_STOP ( )
   CASE #SUCH_START
      SUCHEN (P1,P2,P3,P4,B1 ) ; Ini Nah, Ini Fern, red. Geschwindigkeit, Merker/Eingaenge, SPS trigger
   CASE #SUCH_STOP
      RESUME_UP ( )
   CASE #VW_SPS_INIT
      AE_SPS_INIT ( )
      VW_SGB_S_INIT ( )
   CASE #VW_SPS_CYC
      AE_SPS_CYC ( )
      VW_SGB_S_LOOP ( )
   CASE #VW_AUE_INIT
      $CYCFLAG[255]=TRUE
      $CYCFLAG[254]=$CYCFLAG[255]
      AUE_INIT ( )
   CASE #VW_AUE_WAIT
      AUE_WAIT ( )
   CASE #VW_AUE_END
      AUE_END ( )
   CASE #VW_ZANGE
      SUB_ZANGE ( )
   CASE #VW_WEAV
      WEAVING (B1,P1,P2,P3,P4 )
   CASE #VW_WEAV_C_SP
      SP_WEAVING_C (B1,P1,P2,P3,P4 )
   CASE #VW_WEAV_C
      WEAVING_C (B1,P1,P2,P3,P4 )
   CASE #VW_P_FREE
      SPS_P_FREE ( )
      VW_USER (#USR_CANCEL )
      VW_USR_S (#USR_CANCEL )
   CASE #VW_P_RESET
      SPS_P_RESET ( )
      VW_USER (#USR_RESET )
      VW_USR_S (#USR_RESET )
      ANA_ACTIVE_INIT()
   CASE #MOVE_BCO
      SPSMOVEBCO ( )
   CASE #VERR_EIN
      VW_VERR_EIN (P1,P2,P3,P4 )
   CASE #VERR_AUS
      VW_VERR_AUS (P1 )
   CASE #IBS_CHANGE
      IBS_ALTERNAT (P1,P2,B1 ) ;Segment , Teilnehmer , EIN/AUS
   CASE #VW_SPECIAL_MAKRO
      VW_SPECIAL_MAKRO (B1 )
   DEFAULT
   ENDSWITCH
   PEXIT:
END
DEF  INIT_PROG ( )
   ; reset timer for FB ONL pulse
   $TIMER[61]=0
   $TIMER_STOP[61]=TRUE
   BAS (#INITMOV )
   $LOOP_MSG[]="                                                                                                                                "
   $CYCFLAG[254]=$CYCFLAG[255]
   FB_STATE.N=0
END
DEF  BINOUT (B_NR :IN,NR :IN )
   INT B_NR,NR 
   $B_OUT[B_NR]=NR
END
DEF  BINOUTVPROP (B_NR :IN,FACTOR :IN,MODE :IN,OFFSET :IN )
   INT B_NR, FACTOR, MODE, OFFSET
   IF(MODE ==1) THEN
      $B_OUT[B_NR]=FACTOR
   ENDIF
   IF(MODE ==2) THEN
      IF FACTOR==0 THEN
         FACTOR=2E+06
      ENDIF
      $B_OUT[B_NR]=$VEL_ACT*(1000/FACTOR)+OFFSET
   ENDIF
END
DEF  GUN (GUN_NO :IN,OPEN_GUN :IN )
   INT GUN_NO,OPEN_GUN
   SWITCH  DEF_ZANGE[GUN_NO].TYP
   CASE 1,3
      IF OPEN_GUN>0 THEN
         ; gun open
         IF DEF_ZANGE[GUN_NO].A_AUF>0 THEN
            $OUT[DEF_ZANGE[GUN_NO].A_AUF]=TRUE
         ENDIF
         IF DEF_ZANGE[GUN_NO].A_ZU>0 THEN
            $OUT[DEF_ZANGE[GUN_NO].A_ZU]=FALSE
         ENDIF
      ELSE
         ; gun close
         IF DEF_ZANGE[GUN_NO].A_AUF>0 THEN
            $OUT[DEF_ZANGE[GUN_NO].A_AUF]=FALSE
         ENDIF
         IF DEF_ZANGE[GUN_NO].A_ZU>0 THEN
            $OUT[DEF_ZANGE[GUN_NO].A_ZU]=TRUE
         ENDIF
      ENDIF
   CASE 2,4
      IF OPEN_GUN>0 THEN
         ; gun open
         IF DEF_ZANGE[GUN_NO].A_ZU>0 THEN
            $OUT[DEF_ZANGE[GUN_NO].A_ZU]=FALSE
         ENDIF
         IF DEF_ZANGE[GUN_NO].A_AUF>0 THEN
            PULSE ($OUT[DEF_ZANGE[GUN_NO].A_AUF],TRUE,PULS_TIME )
         ENDIF
      ELSE
         ; gun close
         IF DEF_ZANGE[GUN_NO].A_AUF>0 THEN
            $OUT[DEF_ZANGE[GUN_NO].A_AUF]=FALSE
         ENDIF
         IF DEF_ZANGE[GUN_NO].A_ZU>0 THEN
            PULSE ($OUT[DEF_ZANGE[GUN_NO].A_ZU],TRUE,PULS_TIME )
         ENDIF
      ENDIF
   DEFAULT
   ENDSWITCH
END

GLOBAL DEFFCT INT ANA_ADV_RES(MODE :IN,IFC_NO :IN,ANADEL :IN)
   INT IFC_NO,MODE
   REAL ANADEL
   SWITCH  MODE
      CASE 1 ; constant setting
         RETURN 1
      CASE 2 ; velocity depending 
         SWITCH  IFC_NO
         CASE 1
            RETURN ADV_RES(ANA_DEL_AKTIV1,ANADEL,ANA_DELAY1)
         CASE 2
            RETURN ADV_RES(ANA_DEL_AKTIV2,ANADEL,ANA_DELAY2)
         CASE 3
            RETURN ADV_RES(ANA_DEL_AKTIV3,ANADEL,ANA_DELAY3)
         CASE 4
            RETURN ADV_RES(ANA_DEL_AKTIV4,ANADEL,ANA_DELAY4)
         CASE 5
            RETURN ADV_RES(ANA_DEL_AKTIV5,ANADEL,ANA_DELAY5)
         CASE 6
            RETURN ADV_RES(ANA_DEL_AKTIV6,ANADEL,ANA_DELAY6)
         CASE 7
            RETURN ADV_RES(ANA_DEL_AKTIV7,ANADEL,ANA_DELAY7)
         CASE 8
            RETURN ADV_RES(ANA_DEL_AKTIV8,ANADEL,ANA_DELAY8)
         CASE 9
            RETURN ADV_RES(ANA_DEL_AKTIV9,ANADEL,ANA_DELAY9)
         CASE 10
            RETURN ADV_RES(ANA_DEL_AKTIV10,ANADEL,ANA_DELAY10)
         CASE 11
            RETURN ADV_RES(ANA_DEL_AKTIV11,ANADEL,ANA_DELAY11)
         CASE 12
            RETURN ADV_RES(ANA_DEL_AKTIV12,ANADEL,ANA_DELAY12)
         CASE 13
            RETURN ADV_RES(ANA_DEL_AKTIV13,ANADEL,ANA_DELAY13)
         CASE 14
            RETURN ADV_RES(ANA_DEL_AKTIV14,ANADEL,ANA_DELAY14)
         CASE 15
            RETURN ADV_RES(ANA_DEL_AKTIV15,ANADEL,ANA_DELAY15)
         CASE 16
            RETURN ADV_RES(ANA_DEL_AKTIV16,ANADEL,ANA_DELAY16)
         ENDSWITCH         
      CASE 3 ; weave amplitude depending
         RETURN 1
      DEFAULT  
         RETURN 0            
	ENDSWITCH
   RETURN 0
ENDFCT

GLOBAL DEFFCT INT ADV_RES(ACTIVE :IN,ANADEL :IN,LASTDEL :IN)
   BOOL ACTIVE
   REAL ANADEL,LASTDEL 
   IF (ACTIVE==TRUE) THEN
      IF (ANADEL==LASTDEL) THEN
         RETURN 1;
      ELSE
         RETURN 0
      ENDIF           
   ELSE
      RETURN 0
   ENDIF   
   RETURN 0
ENDFCT

DEF  ANAOUT (MODE :IN,IFC_NO :IN,FACTOR :IN,OFFSET :IN )
   INT IFC_NO,MODE,OFFSET
   REAL FACTOR
   SWITCH  MODE
   CASE 1 ; constant setting
      IF IFC_NO==1 THEN
         ANOUT OFF ANA1
         ANA_DEL_AKTIV1=FALSE
         ANA_DEL_VALUE1=0
      ENDIF
      IF IFC_NO==2 THEN
         ANOUT OFF ANA2
         ANA_DEL_AKTIV2=FALSE
         ANA_DEL_VALUE2=0
      ENDIF
      IF IFC_NO==3 THEN
         ANOUT OFF ANA3
         ANA_DEL_AKTIV3=FALSE
         ANA_DEL_VALUE3=0
      ENDIF
      IF IFC_NO==4 THEN
         ANOUT OFF ANA4
         ANA_DEL_AKTIV4=FALSE
         ANA_DEL_VALUE4=0
      ENDIF
      IF IFC_NO==5 THEN
         ANOUT OFF ANA5
         ANA_DEL_AKTIV5=FALSE
         ANA_DEL_VALUE5=0
      ENDIF
      IF IFC_NO==6 THEN
         ANOUT OFF ANA6
         ANA_DEL_AKTIV6=FALSE
         ANA_DEL_VALUE6=0
      ENDIF
      IF IFC_NO==7 THEN
         ANOUT OFF ANA7
         ANA_DEL_AKTIV7=FALSE
         ANA_DEL_VALUE7=0
      ENDIF
      IF IFC_NO==8 THEN
         ANOUT OFF ANA8
         ANA_DEL_AKTIV8=FALSE
         ANA_DEL_VALUE8=0
      ENDIF
      IF IFC_NO==9 THEN
         ANOUT OFF ANA9
         ANA_DEL_AKTIV9=FALSE
         ANA_DEL_VALUE9=0
      ENDIF
      IF IFC_NO==10 THEN
         ANOUT OFF ANA10
         ANA_DEL_AKTIV10=FALSE
         ANA_DEL_VALUE10=0
      ENDIF
      IF IFC_NO==11 THEN
         ANOUT OFF ANA11
         ANA_DEL_AKTIV11=FALSE
         ANA_DEL_VALUE11=0
      ENDIF
      IF IFC_NO==12 THEN
         ANOUT OFF ANA12
         ANA_DEL_AKTIV12=FALSE
         ANA_DEL_VALUE12=0
      ENDIF
      IF IFC_NO==13 THEN
         ANOUT OFF ANA13
         ANA_DEL_AKTIV13=FALSE
         ANA_DEL_VALUE13=0
      ENDIF
      IF IFC_NO==14 THEN
         ANOUT OFF ANA14
         ANA_DEL_AKTIV14=FALSE
         ANA_DEL_VALUE14=0
      ENDIF
      IF IFC_NO==15 THEN
         ANOUT OFF ANA15
         ANA_DEL_AKTIV15=FALSE
         ANA_DEL_VALUE15=0
      ENDIF
      IF IFC_NO==16 THEN
         ANOUT OFF ANA16
         ANA_DEL_AKTIV16=FALSE
         ANA_DEL_VALUE16=0
      ENDIF
      $ANOUT[IFC_NO]=FACTOR*1E-04
   CASE 2 ; velocity depending
      SWITCH  IFC_NO
      CASE 1
         OFS1=OFFSET*1E-04
         IF FACTOR==0 THEN
            FACTOR=2E+06
         ENDIF
         FAC1=1000/FACTOR
         ANOUT ON ANA1=$VEL_ACT*FAC1+OFS1 DELAY= ANA_DELAY1 MINIMUM=-1 MAXIMUM=1
         ANA_DEL_AKTIV1=TRUE
         ANA_DEL_VALUE1=ANA_DELAY1
      CASE 2
         OFS2=OFFSET*1E-04
         IF FACTOR==0 THEN
            FACTOR=2E+06
         ENDIF
         FAC2=1000/FACTOR
         ANOUT ON ANA2=$VEL_ACT*FAC2+OFS2 DELAY= ANA_DELAY2 MINIMUM=-1 MAXIMUM=1
         ANA_DEL_AKTIV2=TRUE
         ANA_DEL_VALUE2=ANA_DELAY2
      CASE 3
         OFS3=OFFSET*1E-04
         IF FACTOR==0 THEN
            FACTOR=2E+06
         ENDIF
         FAC3=1000/FACTOR
         ANOUT ON ANA3=$VEL_ACT*FAC3+OFS3 DELAY= ANA_DELAY3 MINIMUM=-1 MAXIMUM=1
         ANA_DEL_AKTIV3=TRUE
         ANA_DEL_VALUE3=ANA_DELAY3
      CASE 4
         OFS4=OFFSET*1E-04
         IF FACTOR==0 THEN
            FACTOR=2E+06
         ENDIF
         FAC4=1000/FACTOR
         ANOUT ON ANA4=$VEL_ACT*FAC4+OFS4 DELAY= ANA_DELAY4 MINIMUM=-1 MAXIMUM=1
         ANA_DEL_AKTIV4=TRUE
         ANA_DEL_VALUE4=ANA_DELAY4
      CASE 5
         OFS5=OFFSET*1E-04
         IF FACTOR==0 THEN
            FACTOR=2E+06
         ENDIF
         FAC5=1000/FACTOR
         ANOUT ON ANA5=$VEL_ACT*FAC5+OFS5 DELAY= ANA_DELAY5 MINIMUM=-1 MAXIMUM=1
         ANA_DEL_AKTIV5=TRUE
         ANA_DEL_VALUE5=ANA_DELAY5
      CASE 6
         OFS6=OFFSET*1E-04
         IF FACTOR==0 THEN
            FACTOR=2E+06
         ENDIF
         FAC6=1000/FACTOR
         ANOUT ON ANA6=$VEL_ACT*FAC6+OFS6 DELAY= ANA_DELAY6 MINIMUM=-1 MAXIMUM=1
         ANA_DEL_AKTIV6=TRUE
         ANA_DEL_VALUE6=ANA_DELAY6
      CASE 7
         OFS7=OFFSET*1E-04
         IF FACTOR==0 THEN
            FACTOR=2E+06
         ENDIF
         FAC7=1000/FACTOR
         ANOUT ON ANA7=$VEL_ACT*FAC7+OFS7 DELAY= ANA_DELAY7 MINIMUM=-1 MAXIMUM=1
         ANA_DEL_AKTIV7=TRUE
         ANA_DEL_VALUE7=ANA_DELAY7
      CASE 8
         OFS8=OFFSET*1E-04
         IF FACTOR==0 THEN
            FACTOR=2E+06
         ENDIF
         FAC8=1000/FACTOR
         ANOUT ON ANA8=$VEL_ACT*FAC8+OFS8 DELAY= ANA_DELAY8 MINIMUM=-1 MAXIMUM=1
         ANA_DEL_AKTIV8=TRUE
         ANA_DEL_VALUE8=ANA_DELAY8
      CASE 9
         OFS9=OFFSET*1E-04
         IF FACTOR==0 THEN
            FACTOR=2E+06
         ENDIF
         FAC9=1000/FACTOR
         ANOUT ON ANA9=$VEL_ACT*FAC9+OFS9 DELAY= ANA_DELAY9 MINIMUM=-1 MAXIMUM=1
         ANA_DEL_AKTIV9=TRUE
         ANA_DEL_VALUE9=ANA_DELAY9
      CASE 10
         OFS10=OFFSET*1E-04
         IF FACTOR==0 THEN
            FACTOR=2E+06
         ENDIF
         FAC10=1000/FACTOR
         ANOUT ON ANA10=$VEL_ACT*FAC10+OFS10 DELAY= ANA_DELAY10 MINIMUM=-1 MAXIMUM=1
         ANA_DEL_AKTIV10=TRUE
         ANA_DEL_VALUE10=ANA_DELAY10
      CASE 11
         OFS11=OFFSET*1E-04
         IF FACTOR==0 THEN
            FACTOR=2E+06
         ENDIF
         FAC11=1000/FACTOR
         ANOUT ON ANA11=$VEL_ACT*FAC11+OFS11 DELAY= ANA_DELAY11 MINIMUM=-1 MAXIMUM=1
         ANA_DEL_AKTIV11=TRUE
         ANA_DEL_VALUE11=ANA_DELAY11
      CASE 12
         OFS12=OFFSET*1E-04
         IF FACTOR==0 THEN
            FACTOR=2E+06
         ENDIF
         FAC12=1000/FACTOR
         ANOUT ON ANA12=$VEL_ACT*FAC12+OFS12 DELAY= ANA_DELAY12 MINIMUM=-1 MAXIMUM=1
         ANA_DEL_AKTIV12=TRUE
         ANA_DEL_VALUE12=ANA_DELAY12
      CASE 13
         OFS13=OFFSET*1E-04
         IF FACTOR==0 THEN
            FACTOR=2E+06
         ENDIF
         FAC13=1000/FACTOR
         ANOUT ON ANA13=$VEL_ACT*FAC13+OFS13 DELAY= ANA_DELAY13 MINIMUM=-1 MAXIMUM=1
         ANA_DEL_AKTIV13=TRUE
         ANA_DEL_VALUE13=ANA_DELAY13
      CASE 14
         OFS14=OFFSET*1E-04
         IF FACTOR==0 THEN
            FACTOR=2E+06
         ENDIF
         FAC14=1000/FACTOR
         ANOUT ON ANA14=$VEL_ACT*FAC14+OFS14 DELAY= ANA_DELAY14 MINIMUM=-1 MAXIMUM=1
         ANA_DEL_AKTIV14=TRUE
         ANA_DEL_VALUE14=ANA_DELAY14
      CASE 15
         OFS15=OFFSET*1E-04
         IF FACTOR==0 THEN
            FACTOR=2E+06
         ENDIF
         FAC15=1000/FACTOR
         ANOUT ON ANA15=$VEL_ACT*FAC15+OFS15 DELAY= ANA_DELAY15 MINIMUM=-1 MAXIMUM=1
         ANA_DEL_AKTIV15=TRUE
         ANA_DEL_VALUE15=ANA_DELAY15
      CASE 16
         OFS16=OFFSET*1E-04
         IF FACTOR==0 THEN
            FACTOR=2E+06
         ENDIF
         FAC16=1000/FACTOR
         ANOUT ON ANA16=$VEL_ACT*FAC16+OFS16 DELAY= ANA_DELAY16 MINIMUM=-1 MAXIMUM=1
         ANA_DEL_AKTIV16=TRUE
         ANA_DEL_VALUE16=ANA_DELAY16
      ENDSWITCH
   CASE 3 ; weave amplitude depending
      FAC1=OFFSET*1E-04
      OFS1=FACTOR*1E-04
      SWITCH  IFC_NO
      CASE 1
         ANOUT ON ANA1=FAC1*$TECHVAL[3]+OFS1
         ANA_DEL_AKTIV1=FALSE
         ANA_DEL_VALUE1=0
      CASE 2
         ANOUT ON ANA2=FAC1*$TECHVAL[3]+OFS1
         ANA_DEL_AKTIV2=FALSE
         ANA_DEL_VALUE2=0
      CASE 3
         ANOUT ON ANA3=FAC1*$TECHVAL[3]+OFS1
         ANA_DEL_AKTIV3=FALSE
         ANA_DEL_VALUE3=0
      CASE 4
         ANOUT ON ANA4=FAC1*$TECHVAL[3]+OFS1
         ANA_DEL_AKTIV4=FALSE
         ANA_DEL_VALUE4=0
      CASE 5
         ANOUT ON ANA5=FAC1*$TECHVAL[3]+OFS1
         ANA_DEL_AKTIV5=FALSE
         ANA_DEL_VALUE5=0
      CASE 6
         ANOUT ON ANA6=FAC1*$TECHVAL[3]+OFS1
         ANA_DEL_AKTIV6=FALSE
         ANA_DEL_VALUE6=0
      CASE 7
         ANOUT ON ANA7=FAC1*$TECHVAL[3]+OFS1
         ANA_DEL_AKTIV7=FALSE
         ANA_DEL_VALUE7=0
      CASE 8
         ANOUT ON ANA8=FAC1*$TECHVAL[3]+OFS1
         ANA_DEL_AKTIV8=FALSE
         ANA_DEL_VALUE8=0
      CASE 9
         ANOUT ON ANA9=FAC1*$TECHVAL[3]+OFS1
         ANA_DEL_AKTIV9=FALSE
         ANA_DEL_VALUE9=0
      CASE 10
         ANOUT ON ANA10=FAC1*$TECHVAL[3]+OFS1
         ANA_DEL_AKTIV10=FALSE
         ANA_DEL_VALUE10=0
      CASE 11
         ANOUT ON ANA11=FAC1*$TECHVAL[3]+OFS1
         ANA_DEL_AKTIV11=FALSE
         ANA_DEL_VALUE11=0
      CASE 12
         ANOUT ON ANA12=FAC1*$TECHVAL[3]+OFS1
         ANA_DEL_AKTIV12=FALSE
         ANA_DEL_VALUE12=0
      CASE 13
         ANOUT ON ANA13=FAC1*$TECHVAL[3]+OFS1
         ANA_DEL_AKTIV13=FALSE
         ANA_DEL_VALUE13=0
      CASE 14
         ANOUT ON ANA14=FAC1*$TECHVAL[3]+OFS1
         ANA_DEL_AKTIV14=FALSE
         ANA_DEL_VALUE14=0
      CASE 15
         ANOUT ON ANA15=FAC1*$TECHVAL[3]+OFS1
         ANA_DEL_AKTIV15=FALSE
         ANA_DEL_VALUE15=0
      CASE 16
         ANOUT ON ANA16=FAC1*$TECHVAL[3]+OFS1
         ANA_DEL_AKTIV16=FALSE
         ANA_DEL_VALUE16=0
      ENDSWITCH
   CASE 4 ; Check Vprop value
         IF FACTOR==0 THEN
            V_PROP=2E+06
         ELSE
            V_PROP=1000.0/FACTOR
         ENDIF
ENDSWITCH
END
DEF  COUNTER (CNT_NO :IN,VALUE :IN )
   INT CNT_NO,VALUE
   $COUNT_I[CNT_NO]=VALUE
END
DEF  SET_TIMER (TIMER_NO :IN,TIMER_STOP :IN,TIMER_VALUE :IN )
   INT TIMER_NO,TIMER_STOP,TIMER_VALUE
   IF TIMER_STOP>0 THEN
      ; timer stop
      $TIMER_STOP[TIMER_NO]=TRUE
   ELSE
      ; timer start with value
      $TIMER[TIMER_NO]=TIMER_VALUE*100
      $TIMER_STOP[TIMER_NO]=FALSE
   ENDIF
END
DEF  MPARA ( )
   ; start pulse timer for FB ONL
   $ADVANCE=1	
   CONTINUE
   IF  ((NOT $ON_PATH) OR BSTEP_FLAG) THEN
      $ACT_TOOL=-1
      $ACT_BASE=-1
      $LOOP_MSG[]="                                                                                                                                "
      IF (NOT INT10) OR (NOT EG_SERVO_INIT) THEN
         T_INT10 ( )
      ENDIF
      IF (($PROG_INFO[2].P_STATE<>#P_ACTIVE) AND (STOP_FLAG)) THEN
         T_SUB ( )
      ENDIF
      INTERRUPT ON 10
      WAIT SEC 0.05
      ;FB_ONL - Flanke
      $TIMER[61]=-250
      $TIMER_STOP[61]=FALSE
      IF $PRO_MODE<>#BSTEP THEN
         WAIT FOR (($CYCFLAG[254]) OR ($TIMER[61]>-10))
      ENDIF
      WAIT SEC 0.15
      $TIMER[61]=1
      VW_CBY_MPARA_FBSTOP = TRUE
      FB_STOP ()
      VW_CBY_MPARA_FBSTOP = FALSE
      BSTEP_FLAG=FALSE
      $LOOP_MSG[]="                                                                                                                                "
   ENDIF
   ; check Interbus segment
   ;CHECK_IBS ()
  
  IF (VW_MPARA_ACT.TOOL_NO <> 0) THEN
    IF (MACHINE_TOOL_DAT[VW_MPARA_ACT.TOOL_NO].MACH_DEF_INDEX <> 0) THEN
      IF (MACHINE_DEF[MACHINE_TOOL_DAT[VW_MPARA_ACT.TOOL_NO].MACH_DEF_INDEX].COOP_KRC_INDEX <> 1) THEN
        repeat
          halt; Illegal Use Of Remote Tool
        until FALSE
      ENDIF
    ENDIF
  ENDIF
  
  ;Set IPO_MODE, $TOOL and $LOAD
  IF (VW_MPARA_ACT.BASE_NO <> 0) THEN
    SWITCH BASE_TYPE[VW_MPARA_ACT.BASE_NO]
    CASE #TCP
      $IPO_MODE=#TCP 
    DEFAULT
      $IPO_MODE=#BASE 
    ENDSWITCH
  ELSE
    $IPO_MODE=#BASE 
  ENDIF
  BAS (#TOOL,VW_MPARA_ACT.TOOL_NO )

   IF $ADAP_ACC<>#NONE THEN
	IF (VW_MPARA_ACT.TOOL_NO <> 0) THEN      
	   IF LOAD_DATA[VW_MPARA_ACT.TOOL_NO].M<0 THEN
            $LOAD.M=$DEF_L_M
            $LOAD.CM=$DEF_L_CM
            $LOAD.J=$DEF_L_J
         ELSE
            $LOAD.M=LOAD_DATA[VW_MPARA_ACT.TOOL_NO].M
            $LOAD.CM=LOAD_DATA[VW_MPARA_ACT.TOOL_NO].CM
            $LOAD.J=LOAD_DATA[VW_MPARA_ACT.TOOL_NO].J
            IF (($LOAD.M<>0) AND ($LOAD.J.X==0) AND ($LOAD.J.Y==0) AND ($LOAD.J.Z==0)) THEN
               $LOAD.J=$DEF_L_J
            ENDIF
         ENDIF
      ELSE
         $LOAD.M=$DEF_L_M
         $LOAD.CM=$DEF_L_CM
         $LOAD.J=$DEF_L_J      
      ENDIF
   ENDIF   
   ;case: Base=0
   IF (VW_MPARA_ACT.BASE_NO == 0) THEN
     BAS (#BASE,0 )
     ;RETURN
   ELSE
     IF (MACHINE_FRAME_DAT[VW_MPARA_ACT.BASE_NO].MACH_DEF_INDEX > 0) Then
       SWITCH  MACHINE_DEF[MACHINE_FRAME_DAT[VW_MPARA_ACT.BASE_NO].MACH_DEF_INDEX].MECH_TYPE
       CASE #NONE
         IF (VW_MPARA_ACT.BASE_NO <= MAX_BASE) THEN
           BAS (#BASE,VW_MPARA_ACT.BASE_NO )
         ENDIF
       CASE #ROBOT
         IF (MACHINE_DEF[MACHINE_FRAME_DAT[VW_MPARA_ACT.BASE_NO].MACH_DEF_INDEX].COOP_KRC_INDEX > 1) THEN
           BAS (#LK_BASE,VW_MPARA_ACT.BASE_NO )
         ENDIF
         IF (MACHINE_DEF[MACHINE_FRAME_DAT[VW_MPARA_ACT.BASE_NO].MACH_DEF_INDEX].COOP_KRC_INDEX == 1) THEN
           BAS (#BASE,VW_MPARA_ACT.BASE_NO )
         ENDIF
       CASE #EASYS,#EBSYS,#ECSYS,#EDSYS,#EESYS,#EFSYS,#ERSYS
         IF (MACHINE_DEF[MACHINE_FRAME_DAT[VW_MPARA_ACT.BASE_NO].MACH_DEF_INDEX].COOP_KRC_INDEX > 1) THEN
           BAS (#LK_BASE,VW_MPARA_ACT.BASE_NO )
         ENDIF
         IF (MACHINE_DEF[MACHINE_FRAME_DAT[VW_MPARA_ACT.BASE_NO].MACH_DEF_INDEX].COOP_KRC_INDEX == 1) THEN
            BAS (#EX_BASE,VW_MPARA_ACT.BASE_NO )
         ENDIF
       CASE #CONVEYOR
         repeat
           halt;not programed yet
         until false
         ENDSWITCH
     ELSE
       IF (VW_MPARA_ACT.BASE_NO <= MAX_BASE) THEN
         BAS (#BASE,VW_MPARA_ACT.BASE_NO )
       ENDIF
     ENDIF
   ENDIF 
   IF NO_MPARA_ASSIGN THEN
      NO_MPARA_ASSIGN=FALSE
      RETURN
   ENDIF
   ;*******************************************
   ; RVM deaktivieren; Filter zurcksetzen
   ;*******************************************
   CONTINUE ; nur wenn letzter Punkt nicht berschliffen und nach Satzanwahl
   IF (VW_MPARA_ACT_BACKUP.VE == 0) OR ($MOVE_BCO==TRUE) THEN
     CONTINUE;
     IF ($FILTER <> $DEF_FLT_PTP) THEN
       $FILTER = $DEF_FLT_PTP
     ENDIF
   ENDIF
   IF VW_MPARA_ACT.MOVE_TYPE==#GLUE_MOTION THEN
      $VEL.CP=VW_MPARA_ACT.VB*0.001
      $VEL.ORI1=DEF_VEL_ORI1
      $VEL.ORI2=DEF_VEL_ORI2
      $ACC.CP=$ACC_MA.CP*VW_MPARA_ACT.ACC*0.01
      $ACC.ORI1=$ACC_MA.ORI1*VW_MPARA_ACT.ACC*0.01
      $ACC.ORI2=$ACC_MA.ORI2*VW_MPARA_ACT.ACC*0.01
      IF VW_MPARA_ACT.VE>0 THEN
         $APO.CDIS=VW_MPARA_ACT.VE
      ELSE
         $APO.CDIS=DEF_APO_CDIS
      ENDIF
      RETURN
   ENDIF
   IF VW_MPARA_ACT.MOVE_TYPE==#KPTP_MOTION THEN
      VW_MPARA_ACT_BACKUP=VW_MPARA_ACT
      BAS (#VEL_PTP,VW_MPARA_ACT.VB )
      BAS (#ACC_PTP,VW_MPARA_ACT.ACC )
      IF VW_MPARA_ACT.VE>0 THEN
         $APO.CDIS=VW_MPARA_ACT.VE
      ELSE
         $APO.CDIS=DEF_APO_CDIS
      ENDIF
      RETURN
   ENDIF
   IF VW_MPARA_ACT.MOVE_TYPE==#PTP_MOTION THEN
      VW_MPARA_ACT_BACKUP=VW_MPARA_ACT
      BAS (#VEL_PTP,VW_MPARA_ACT.VB )
      BAS (#ACC_PTP,VW_MPARA_ACT.ACC )
      IF VW_MPARA_ACT.VE>0 THEN
         $APO.CPTP=VW_MPARA_ACT.VE
      ELSE
         $APO.CPTP=DEF_APO_CPTP
      ENDIF
   ELSE ;CP-Motion
      BAS (#VEL_CP,VW_MPARA_ACT.VB*0.001 )
      $VEL.ORI1=DEF_VEL_ORI1
      $VEL.ORI2=DEF_VEL_ORI2
      BAS (#ACC_CP,VW_MPARA_ACT.ACC )
      IF VW_MPARA_ACT.VE>0 THEN
         $APO.CVEL=VW_MPARA_ACT.VE
      ELSE
         $APO.CVEL=DEF_APO_CVEL
      ENDIF
   ENDIF
END
DEF  FB_LOOP_MSG ( )
  DECL STATE_T STATE
  INT OFFSET,V_OFFSET,INT_N
  INT VERR_NR, OUT_NR
  BOOL MIT_VERR
  DECL CHAR MY_MSG[470]
  IF (DETECT_LMS (VERR_NR, OUT_NR)) THEN
    $OUT[OUT_NR]=FALSE   ;Freigabeausgang wieder zuruecksetzen
    ;--- Meldung, dass Verriegelungsausgang <Out_Nr> in der Verrieglung Nr. <Verr_Nr> ueberschrieben wurde ---
    MAKE_LMS_MSG (VERR_NR, OUT_NR)
  ENDIF
  OFFSET=0
  MIT_VERR=FALSE
  MY_MSG[]="                                                                                                                              "
  SWRITE(MY_MSG[],STATE,OFFSET,GETCYCDEF(254),0)
  IF (StrFind (1,MY_MSG[], "M255",#NOT_CASE_SENS) == 1) THEN
    OFFSET=0
    MY_MSG[]="                                                                                                                              "
    SWRITE(MY_MSG[],STATE,OFFSET,GETCYCDEF(255),0)
    IF (StrFind (1,MY_MSG[], "EIN",#NOT_CASE_SENS) == 1) THEN
      $LOOP_MSG[]="                                                                                                                                "
      OFFSET=0
    ELSE
      $LOOP_MSG[]="                                                                                                                                "
      OFFSET=0
      SWRITE($LOOP_MSG[],STATE,OFFSET,GETCYCDEF(254),0)
      OFFSET=OFFSET+1      
    ENDIF
  ELSE
    $LOOP_MSG[]="                                                                                                                                "
    OFFSET=0
    SWRITE($LOOP_MSG[],STATE,OFFSET,GETCYCDEF(254),0)
    OFFSET=OFFSET+1
  ENDIF
  V_OFFSET=0
  FOR INT_N=1 TO  8
    IF VW_VERR[INT_N].IN<>$IOSYS_IN_TRUE THEN
      MIT_VERR=TRUE
    ENDIF
  ENDFOR
  IF MIT_VERR THEN
    IF ((OFFSET+V_OFFSET)>110) THEN
          IF OFFSET>0 THEN
            SWRITE($LOOP_MSG[],STATE,OFFSET,"&",0)
          ENDIF
      SWRITE($LOOP_MSG[],STATE,OFFSET," M255",0)
    ELSE
      FOR INT_N=1 TO  8
        IF VW_VERR[INT_N].IN<>$IOSYS_IN_TRUE THEN
          SWRITE($LOOP_MSG[],STATE,OFFSET,"&",0)
          SWRITE($LOOP_MSG[],STATE,OFFSET,VW_VERR[INT_N].NAME[],0)
        ENDIF
      ENDFOR
    ENDIF
  ENDIF
END
DEF  MAKE_LMS_MSG (VERR_NR :IN, OUT_NR :IN)
  DECL INT VERR_NR
  DECL INT OUT_NR
  DECL KrlMsg_T Msg
  DECL KrlMsgPar_T Par[3]
  DECL KrlMsgOpt_T Opt
  DECL INT nHandle
  DECL INT OFFSET
  DECL STATE_T STATE
  OFFSET=0
  Msg = { Modul[] "TPVW", Nr 201, Msg_txt[] "VERR_FRG_LMS"}
  Par[1].Par_type=#Value
  Par[1].Par_txt[]=","
  SWRITE(Par[1].Par_txt[],STATE,OFFSET,"A%d, ",OUT_NR)
  SWRITE(Par[1].Par_txt[],STATE,OFFSET,"VERR_%d",VERR_NR)  
  Opt = {VL_Stop TRUE, Clear_P_Reset TRUE, Log_To_DB FALSE}
  nHandle = Set_KrlMsg (#Quit, Msg, Par[], Opt)
  WHILE (Exists_KrlMsg(nHandle)) 
    WAIT SEC 0.1
    HALT
  ENDWHILE
  WAIT SEC 0.2   
END
DEF  FB_SAVE_MSG ( )
   DECL STATE_T STATE
   INT OFFSET
   L_MSG_SAVE[]="                                                                                                                              "
   IF ($LOOP_MSG[1]<>" ") OR ($LOOP_MSG[2]<>" ") OR ($LOOP_MSG[3]<>" ") THEN
      L_MSG_SAVE[]=" "
      OFFSET=0
      SWRITE(L_MSG_SAVE[],STATE,OFFSET,$LOOP_MSG[],0)
   ENDIF
END
DEF  FB_LOAD_MSG ( )
   DECL STATE_T STATE
   INT OFFSET
   $LOOP_MSG[]="                                                                                                                                "
   OFFSET=0
   SWRITE($LOOP_MSG[],STATE,OFFSET,L_MSG_SAVE[],0)
END
DEF  FB_CHECK ( )
   IF $CYCFLAG[254] AND ($TIMER[61]<0) THEN
      BRAKE
      IF $PRO_MODE<>#BSTEP THEN
         WAIT FOR  ($TIMER[61]>0)
      ENDIF
   ENDIF
   $LOOP_CONT=TRUE
   WAIT FOR  $CYCFLAG[254] OR ( NOT ($LOOP_CONT) AND ($MODE_OP<>#EX))
   $LOOP_CONT=TRUE
END
DEF  FB_STOP ( )
   INT INT_N
   BOOL EXIT_OK
   BOOL IN_APO_1
   IN_APO_1= NOT (($MOVE_STATE==#PTP_AP02) OR ($MOVE_STATE==#LIN_AP02) OR ($MOVE_STATE==#CIRC_AP02))
   IF ((IN_APO_1) OR (NOT SEARCH_ACTIV)) THEN
      $VW_FB_HOLD=TRUE
   ENDIF
   IF ($PRO_MOVE OR (NOT $CYCFLAG[254] AND NOT VW_CBY_MPARA_FBSTOP)) THEN
      BRAKE
   ENDIF
   FB_STATE.APO_2= NOT IN_APO_1
   FB_STATE.N=FB_STATE.N+1
   FB_STATE.HOLD=$VW_FB_HOLD
   FB_SAVE_MSG ( )
   FB_LOOP_MSG ( )
   $LOOP_CONT=TRUE
   EXIT_OK=FALSE
   REPEAT
      WHILE   NOT ($CYCFLAG[254] OR ( NOT ($LOOP_CONT) AND ($MODE_OP<>#EX)))
         IF ($LOOP_MSG[1]==" ") AND ($LOOP_MSG[2]==" ") AND ($LOOP_MSG[3]==" ") THEN
            FB_LOOP_MSG ( )
            WAIT SEC 0.1
            IF ($LOOP_MSG[1]==" ") AND ($LOOP_MSG[2]==" ") AND ($LOOP_MSG[3]==" ") THEN
               $LOOP_MSG[]="KeyWord_WarteFBAus                                                                                                             "
            ENDIF
         ENDIF
         IF $PRO_MOVE THEN
            BRAKE
            IF NOT $ON_PATH THEN
               PTP $AXIS_ACT
            ENDIF
         ENDIF
         IF $PRO_MODE1==#BSTEP THEN
            ;RETURN
         ENDIF
         WAIT SEC 0.001
      ENDWHILE
      IF  NOT $LOOP_CONT THEN
         ;Simuliere-Taste gedrueckt
         $CYCFLAG[254]=TRUE
         FOR INT_N=1 TO  8
            IF  NOT $IN[VW_VERR[INT_N].IN] THEN
               VW_VERR[INT_N].IN=$IOSYS_IN_TRUE
               VW_VERR[INT_N].NAME[]="SIMU   "
            ENDIF
         ENDFOR
         WRITE_VERR_COND (FALSE)  ;Auffrischen der Verriegelungsbedingung
         EXIT_OK=TRUE
         $LOOP_CONT=TRUE
      ELSE
         $TIMER[62]=-150
         $TIMER_STOP[62]=FALSE
         WHILE   NOT ( NOT $CYCFLAG[254] OR ($TIMER[62]>0))
         ENDWHILE
         IF $TIMER[62]>0 THEN
            $TIMER_STOP[62]=TRUE
            EXIT_OK=TRUE
         ELSE
         ENDIF
      ENDIF
      WAIT SEC 0.001
   UNTIL EXIT_OK
   $LOOP_CONT=TRUE
   FB_LOAD_MSG ( )
   WAIT SEC 0.024
   $VW_FB_HOLD=FALSE
END
DEF  TRIG_OUT (NO :IN,MODE :IN,STATE :IN )
   ; set a digital output
   INT NO,MODE
   BOOL STATE
   IF MODE==0 THEN
      $OUT[NO]=STATE
   ELSE
      $FLAG[NO]=STATE
   ENDIF
END
DEF  SUCHEN (E_STOP :IN,E_RED :IN,VEL_RED :IN,INPUT_CASE :IN, SPS_Trig :IN )
   INT E_STOP,E_RED,VEL_RED,INPUT_CASE
   BOOL SPS_Trig
   OV_OLD=$OV_PRO
   SUCH_RED=VEL_RED
   G_LINE_SEL_OK=FALSE
   ; MUE 18.10.2006
   LIN_SUCHEN_OVRED=-1
;AVO
if VW_Suchl_A_Fehler > 0 THEN
	$OUT[VW_Suchl_A_Fehler] = FALSE
ENDIF
if VW_Suchl_F_Fehler > 0 THEN
	$FLAG[VW_Suchl_F_Fehler] = FALSE
ENDIF
VW_Suchl_Stopp = FALSE
VW_Suchl_Last_Dist = 0.0
;AVO Ende
IF (SEARCH_END AND SPS_Trig) THEN
	SEARCH_END = FALSE
	WAIT SEC 0.012
ENDIF
SEARCH_END = FALSE
IF (SPS_Trig) THEN
	INTERRUPT ON 39
ENDIF
INTERRUPT DECL 102 WHEN $OV_PRO<>OLD_OV_PRO DO SET_V_SLW ( )
;AVO
INTERRUPT DECL 103 WHEN $Dist_next >= VW_Suchl_Ziel_Dist DO Suchlauf_Stop()
;AVO Ende		 
   IF (INPUT_CASE == 2) OR (INPUT_CASE == 4) THEN
      WAIT FOR TRUE
      INTERRUPT DECL 101 WHEN $CYCFLAG[E_RED] DO RED_UP (SUCH_RED )
      INTERRUPT ON 101
      WAIT SEC 0.012
      IF $CYCFLAG[E_RED] THEN
      ;Sensor Nah liegt bereits an
         IF $OV_PRO > LIN_SUCHEN_OVRED THEN
            LIN_SUCHEN_OVRED=0.01*$OV_PRO*VEL_RED
            $OV_PRO=LIN_SUCHEN_OVRED 
         ENDIF
      INTERRUPT OFF 101
   ELSE
	;AVO
      VW_Suchl_Dist_M = 0.0
      VW_Suchl_Ziel_Dist = 100.0
      ;AVO Ende
   ENDIF
   ELSE
      WAIT FOR TRUE
      INTERRUPT DECL 101 WHEN $IN[E_RED] DO RED_UP (SUCH_RED )
      INTERRUPT ON 101
      IF $IN[E_RED] THEN
         ;Sensor Nah liegt bereits an
         IF $OV_PRO > LIN_SUCHEN_OVRED THEN
            LIN_SUCHEN_OVRED=0.01*$OV_PRO*VEL_RED
            $OV_PRO=LIN_SUCHEN_OVRED 
         ENDIF 
         INTERRUPT OFF 101
       ELSE
	 ;AVO
       VW_Suchl_Dist_M = 0.0
       VW_Suchl_Ziel_Dist = 100.0
       ;AVO Ende
      ENDIF
   ENDIF
   IF (INPUT_CASE == 3) OR (INPUT_CASE == 4) THEN
      IF  NOT $CYCFLAG[E_STOP] THEN
         INTERRUPT ON 12
         CHECK_OVRED (E_RED,VEL_RED,INPUT_CASE)
         ;AVO
	   if VW_Suchl_Max_Weg > 0 THEN
            $advance = 0
      	INTERRUPT ON 103
	   ENDIF
         Ziel_pos()
         ;AVO Ende
         WAIT SEC 0.01
         IF ($Pro_MODE1<>#GO) THEN
           HALT
         ENDIF
         INTERRUPT OFF 12
         INTERRUPT OFF 101
         INTERRUPT OFF 102
         INTERRUPT OFF 103
         $OV_PRO=OV_OLD
   	   ; MUE 18.10.2006
         LIN_SUCHEN_OVRED=-1
      ELSE
         ;Sensor Fern liegt bereits an
         WAIT SEC 0.012
         INTERRUPT OFF 12
         INTERRUPT OFF 101
         INTERRUPT OFF 102
         INTERRUPT OFF 103
         $OV_PRO=OV_OLD
   	   ; MUE 18.10.2006
         LIN_SUCHEN_OVRED=-1
      ENDIF
   ELSE
      IF  NOT $IN[E_STOP] THEN
         INTERRUPT ON 12
         CHECK_OVRED (E_RED,VEL_RED,INPUT_CASE)
         ;AVO
	   if VW_Suchl_Max_Weg > 0 THEN
            $advance = 0
      	INTERRUPT ON 103
	   ENDIF
         Ziel_pos()
	   ;AVO Ende
         WAIT SEC 0.01
         IF ($Pro_MODE1<>#GO) THEN
           HALT
         ENDIF
         INTERRUPT OFF 12
         INTERRUPT OFF 101
         INTERRUPT OFF 102
         INTERRUPT OFF 103
         $OV_PRO=OV_OLD
   	   ; MUE 18.10.2006
         LIN_SUCHEN_OVRED=-1
      ELSE
         ;Sensor Fern liegt bereits an
         WAIT SEC 0.012
         INTERRUPT OFF 12
         INTERRUPT OFF 101
         INTERRUPT OFF 102
         INTERRUPT OFF 103
         $OV_PRO=OV_OLD
   	   ; MUE 18.10.2006
         LIN_SUCHEN_OVRED=-1
      ENDIF
   ENDIF
END
;AVO
DEF Ziel_pos()
	LIN  Z_PUNKT
END
DEF Suchlauf_Stop ()
	VW_Suchl_Stopp = TRUE
   if VW_Suchl_A_Fehler > 0 THEN
      $OUT[VW_Suchl_A_Fehler] = TRUE
   ENDIF
   if VW_Suchl_F_Fehler > 0 THEN
      $FLAG[VW_Suchl_F_Fehler] = TRUE
   ENDIF
   if VW_Suchl_Stopp and VW_Suchl_SPS_OFF THEN
  		SPS_FERTIG = TRUE
  	ENDIF
   VW (#SUCH_STOP,TRUE)	
END
;AVO Ende
DEF CHECK_OVRED (E_RED :IN,VEL_RED :IN,INPUT_CASE :IN)
   INT E_RED,VEL_RED,INPUT_CASE
   BOOL RESULT
   WAIT SEC 0.01
   SWITCH INPUT_CASE	
      CASE 1, 3
         RESULT=$IN[E_RED]
      CASE 2, 4
         RESULT=$CYCFLAG[E_RED]
   ENDSWITCH
   ; Set vel_red
   IF RESULT THEN
      IF $OV_PRO > LIN_SUCHEN_OVRED THEN
         LIN_SUCHEN_OVRED=0.01*$OV_PRO*VEL_RED
         $OV_PRO=LIN_SUCHEN_OVRED 
      ENDIF
   ENDIF
END
DEF  RESUME_UP ( )
   SUCH_RED=100
   BRAKE
   INTERRUPT OFF 103
   INTERRUPT OFF 102
   INTERRUPT OFF 101
   INTERRUPT OFF 12
   ;AVO
   if VW_Suchl_Stopp and VW_Suchl_SPS_OFF THEN
     INTERRUPT OFF 39
   ENDIF
   If not VW_Suchl_Stopp and (VW_Suchl_Dist_M<0) THEN
	VW_Suchl_Last_Dist = $DIST_NEXT - VW_Suchl_Dist_M
   ENDIF
   VW_Suchl_A_Fehler = 0
   VW_Suchl_F_Fehler = 0
   VW_Suchl_Max_Weg= 0.0
   VW_Suchl_Max_Weg_T1= 0.0
   VW_Suchl_Dist_M = 0.0
   VW_Suchl_Ziel_Dist = 100.0
   VW_Suchl_Stopp = FALSE
   VW_Suchl_SPS_OFF = FALSE
   ;AVO Ende
   ; MUE 18.10.2006
   LIN_SUCHEN_OVRED=-1
   $OV_PRO=OV_OLD
   IF (NOT G_LINE_SEL_OK) THEN
      IF ($Pro_MODE1<>#GO) THEN
        HALT
      ENDIF
      RESUME
      G_LINE_SEL_OK=FALSE
   ELSE
      G_LINE_SEL_OK=FALSE
   ENDIF
END
DEF  RED_UP (V_RED :IN )
   INT V_RED
   INTERRUPT OFF 101
   IF SUCH_RED<>100 THEN
      IF $OV_PRO > LIN_SUCHEN_OVRED THEN
         LIN_SUCHEN_OVRED=0.01*$OV_PRO*V_RED
         $OV_PRO=LIN_SUCHEN_OVRED
         ;AVO
         VW_Suchl_Dist_M = $DIST_NEXT
         VW_Suchl_Ziel_Dist = VW_Suchl_Dist_M + VW_Suchl_Max_Weg
         if ($MODE_OP==#T1) and (VW_Suchl_Max_Weg_T1 > 0) THEN
	      VW_Suchl_Ziel_Dist = VW_Suchl_Dist_M + VW_Suchl_Max_Weg_T1
         ENDIF
         ;AVO Ende 
      ENDIF      
      INTERRUPT ON 102              
   ENDIF
END
DEF SET_V_SLW ( )               
   IF $OV_PRO > LIN_SUCHEN_OVRED THEN
      LIN_SUCHEN_OVRED=0.01*$OV_PRO*SUCH_RED
      $OV_PRO=LIN_SUCHEN_OVRED 
   ENDIF
END                       
DEF  AE_SPS_INIT ( )
   ; reset Inbetriebnahme-Flag
   INT S
   ; MUE 18.10.2006
   ; Ueberwachung OV Reduzierung LIN SUCHEN
   LIN_SUCHEN_OVRED=-1
   VW_INB=FALSE
   ; reset WPROZ, WSLAV
   OUT_WPROZ=FALSE
   OUT_WSLAV=FALSE
   ; reset Zangentaste
   ZANGEN_FUNKT=0
   $H_POS=$H_POS
   MODE=#SYNC
   ;$Pro_Mode-Umschaltung und Satzanwahl
   LAST_PRMODE=$PRO_MODE1
   WAIT SEC 1.0
   IF $PRO_STATE1==#P_FREE THEN
      ; Automatik Extern Initialisierung (SPS.SUB)
      PRG_NR_REFL = 0
      P0_MERKER=TRUE
   ENDIF
   FOR S=1 TO  8
      VW_VERR[S].IN=$IOSYS_IN_TRUE
      VW_VERR[S].OUT=0
   ENDFOR
END
DEF  WPROZ_WSLAV ( )
   IF  NOT (OUT_WSLAV OR OUT_WPROZ) THEN
      IF I_PROSLA<>0 THEN
         I_PROSLA=0
         B_WSLAV[1]=FALSE
         B_WSLAV[2]=FALSE
         B_WSLAV[3]=FALSE
         B_WPROZ[1]=FALSE
         B_WPROZ[2]=FALSE
         B_WPROZ[3]=FALSE
         $OUT[WPROZ]=FALSE
         $OUT[WSLAV]=FALSE
      ENDIF
      RETURN
   ENDIF
   I_PROSLA=I_PROSLA+1
   IF ((I_PROSLA>=4) OR (I_PROSLA<=0)) THEN
      I_PROSLA=1
   ENDIF
   B_WPROZ[I_PROSLA]=OUT_WPROZ
   B_WSLAV[I_PROSLA]=OUT_WSLAV
   IF (B_WPROZ[1] AND B_WPROZ[2] AND B_WPROZ[3]) THEN
      $OUT[WPROZ]=TRUE
   ENDIF
   IF ( NOT (B_WPROZ[1]) AND  NOT (B_WPROZ[2]) AND  NOT (B_WPROZ[3])) THEN
      $OUT[WPROZ]=FALSE
   ENDIF
   IF (B_WSLAV[1] AND B_WSLAV[2] AND B_WSLAV[3]) THEN
      $OUT[WSLAV]=TRUE
   ENDIF
   IF ( NOT (B_WSLAV[1]) AND  NOT (B_WSLAV[2]) AND  NOT (B_WSLAV[3])) THEN
      $OUT[WSLAV]=FALSE
   ENDIF
END
DEF  AE_SPS_CYC ( )
   ;Automatik Extern Zyklischer Teil im SPS.SUB
   BOOL MERK1
   ; MUE 18.10.2006
   ; Ueberwachung OV Reduzierung LIN SUCHEN
   IF (LIN_SUCHEN_OVRED>0) AND (LIN_SUCHEN_OVRED<=100) THEN
     IF $OV_PRO>LIN_SUCHEN_OVRED THEN  
	 WAIT SEC 0.3
 	 IF (LIN_SUCHEN_OVRED>0) AND (LIN_SUCHEN_OVRED<=100) AND ($OV_PRO>LIN_SUCHEN_OVRED) THEN
         $OV_PRO=LIN_SUCHEN_OVRED
	 ENDIF
     ENDIF
   ENDIF
   IF $PRO_MODE1==#BSTEP THEN
      ;FB_ONL - Flanke
      $TIMER[61]=-300
      $TIMER_STOP[61]=FALSE
      IF NOT BSTEP_FLAG THEN
         $LOOP_MSG[]="                                                                                                                                "
      ENDIF
      BSTEP_FLAG=TRUE
   ENDIF
   IF ((A_QUAL>0) AND (E_QUAL>0)) THEN
      $OUT[A_QUAL]=$IN[E_QUAL]
   ENDIF
   MERK1=$ALARM_STOP AND $USER_SAF
   $OUT[PF0]=(P0_MERKER OR (DownLoadActive AND ($Mode_OP==#EX))) AND $IN_HOME
   IF MERK1==FALSE THEN
      WAIT FOR  $PRO_ACT==FALSE
   ENDIF
   $OUT[RK100]=MERK1
   WPROZ_WSLAV ( )
   IF $PRO_MODE1<>#BSTEP THEN
      IF ((FB_FLAG>0) AND (FB_FLAG<$IOSYS_IN_TRUE)) THEN
         $FLAG[FB_FLAG]=$CYCFLAG[254]
      ENDIF
      IF ((VERR_FLAG>0) AND (VERR_FLAG<$IOSYS_IN_TRUE)) THEN
         $FLAG[VERR_FLAG]=$CYCFLAG[255]
      ENDIF
   ENDIF
   IF ($OUT[PF0] AND VW_CALL_CELL AND ( NOT $PRO_MOVE) AND ($MODE_OP==#EX)) THEN
      CWRITE($CMD,STAT,MODE,"STOP 1")
      CWRITE($CMD,STAT,MODE,"CANCEL 1")
      P_OLD=P_SELECT
      CWRITE($CMD,STAT,MODE,"RUN /R1/CELL ()")
   ENDIF
   ;Aufruf des Makro-SAW
   IF $LINE_SEL_OK THEN
      $LINE_SEL_OK=FALSE
	; MUE 18.10.2006
      LIN_SUCHEN_OVRED=-1
      P0_MERKER=FALSE
      G_LINE_SEL_OK=TRUE; Merker: Satzanwahl durchgefhrt, um ungltigen Resume bei Suchbefehl zu vermeiden
      IF $PRO_STATE1<>#P_ACTIVE THEN
         $LOOP_MSG[]="                                                                                                                                "
      ENDIF
      IF $MODE_OP<>#EX THEN
         MAKROSAW ( )
         IF $TECH_OPT==TRUE THEN
            $TECH_C[1].MODE=#OFF
            $TECH_C[2].MODE=#OFF
            $TECH_C[3].MODE=#OFF
         ENDIF
         VW_USER (#USR_SAW )
         VW_USR_S (#USR_SAW )
         VW_SGB_SAW ( )
      ENDIF
  ENDIF
   ; Override auf 10% setzen bei Wechsel auf Hand
   ; Wird ab Build 62 vom Grundsystem uebernommen
   ;IF NOT DISABLE_OV_CHANGE THEN
   ;   IF ($MODE_OP==#T2) THEN
   ;      IF (OLD_MODE_OP==#EX) THEN
   ;         IF $OV_PRO>=10 THEN
   ;            OLD_OV_PRO=$OV_PRO
   ;            $OV_PRO=10
   ;            OV_CHANGED=TRUE
   ;         ENDIF
   ;      ENDIF
   ;      LAST_OV_PRO=$OV_PRO
   ;   ENDIF
   ;   IF ($MODE_OP==#EX) AND OV_CHANGED THEN
   ;      OV_CHANGED=FALSE
   ;      IF (LAST_OV_PRO==$OV_PRO) THEN
   ;         $OV_PRO=OLD_OV_PRO
   ;      ENDIF
   ;   ENDIF
   ;   OLD_MODE_OP=$MODE_OP
   ;ENDIF
   ; Rueckmeldung Folge loeschen
   IF $PRO_STATE1==#P_FREE THEN
      PRG_NR_REFL = 0
   ENDIF
END
DEF  AUE_INIT ( )
   ;Automatik extern am Anfang der Folge
   INT INT_N
   $ADVANCE=DEF_ADVANCE
   VW_CALL_CELL=FALSE
   P0_MERKER=$IN_HOME
   $OUT[PF0]=$IN_HOME
   DownLoadActive=FALSE
   FOR INT_N=1 TO  8
      VW_VERR[INT_N].IN=$IOSYS_IN_TRUE
      VW_VERR[INT_N].OUT=0
   ENDFOR
   WRITE_VERR_COND (FALSE)
   $LOOP_MSG[]="                                                                                                                                "
   IF PGNO>0 THEN
      IF P_TYPE==0 THEN ;Integer
         P_OLD=PGNO
         P_SELECT=PGNO
      ELSE ;1 AUS N
         P_OLD=LOG_2(PGNO)
         P_SELECT=LOG_2(PGNO)
      ENDIF
   ENDIF
   IF  NOT VW_CBY_CELL THEN
      IF ($MODE_OP==#T1) OR ($MODE_OP==#T2) THEN
         LAST_PRO_NR ( )
         IF PGNO >= 0 THEN
           Err_Clear($Err)        
           On_Error_Proceed       
           PRG_NR_REFL = PGNO
           IF $Err.Number <> 0 THEN
             MSGNOTIFY("ExtWrongProgramNumber", "VwInlineForms",PGNO, , 200)
             HALT
           ENDIF
         ELSE
           PRG_NR_REFL = 0
         ENDIF
      ENDIF
   ENDIF
   ; init online FB
   $CYCFLAG[254]=TRUE
   $CYCFLAG[255]=TRUE
   $CYCFLAG[254]=$CYCFLAG[255]
END
DEFFCT  INT LOG_2(WERT :IN)
   INT CNT,VALUE,WERT
   VALUE=1
   FOR CNT=1 TO  32
      IF WERT==VALUE THEN
         RETURN  CNT
      ENDIF
      VALUE=VALUE*2
   ENDFOR
   IF (CNT>=32) THEN
      RETURN  0
   ENDIF
   RETURN  0
ENDFCT
DEF  AUE_WAIT ( )
   BOOL SIMU_START
   INT P
   $ADVANCE=DEF_ADVANCE
   ;Automatik extern in der Folge
   IF (VW_INB AND $EXTSTARTTYP) THEN
      N_VW=FALSE
      RETURN
   ENDIF
   $H_POS=$AXIS_ACT
   $LOOP_CONT=TRUE
   $LOOP_MSG[]="KeyWord_WarteFolgestartSRB                                                                                                     "
   REPEAT
      P0_MERKER=TRUE
      BITSHIFT=1
      P=0
      N_VW=FALSE
      IF VW_CBY_CELL THEN
         IF (P_TYPE == 0) THEN
            P = PRG_NR
         ELSE
            P = LOG_2(PRG_NR)
         ENDIF
      ENDIF
      IF (P<>P_OLD) THEN
         N_VW=TRUE
      ELSE
         PRG_NR_REFL = PRG_NR
      ENDIF
      IF (P==0) AND VW_INB AND (($MODE_OP==#T1) OR ($MODE_OP==#T2)) THEN
         N_VW=FALSE
         SIMU_START=TRUE
      ELSE
         SIMU_START=FALSE
      ENDIF
      IF ((P==0) OR (P==P_OLD)) AND  NOT ($LOOP_CONT) AND (($MODE_OP==#T1) OR ($MODE_OP==#T2)) THEN
         N_VW=FALSE
         SIMU_START=TRUE
      ENDIF
      IS_CELL ( )
      IF  NOT VW_CBY_CELL THEN
         IF ($MODE_OP==#T1) OR ($MODE_OP==#T2) THEN
            N_VW=FALSE
         ELSE
            VW_CALL_CELL=TRUE
            $LOOP_MSG[]="KeyWord_FuerAutomatikCellAnwaehlen                                                                                             "
            WHILE   NOT (($MODE_OP==#T1) OR ($MODE_OP==#T2))
               WAIT SEC 0.1
            ENDWHILE
            $LOOP_MSG[]="KeyWord_WarteFolgestartSRB                                                                                                     "
         ENDIF
      ENDIF
      OUT_WSLAV=TRUE
      OUT_WPROZ=FALSE
      WAIT SEC 0.001
   UNTIL ((($IN[SRB]==TRUE) AND (P>0)) OR (N_VW==TRUE)) OR SIMU_START
   $LOOP_MSG[]="                                                                                                                                "
   OUT_WSLAV=FALSE
   OUT_WPROZ=FALSE
   IF N_VW==TRUE THEN
      PRG_NR_REFL = 0
   ELSE
      P0_MERKER=FALSE
   ENDIF
   $LOOP_CONT=TRUE
   CHECK_EMI()
END
DEF  AUE_END ( )
   WAIT SEC 0.01
   ;FB ONL deaktivieren
   $CYCFLAG[254]=TRUE
   $OUT[LPKT]=TRUE
   $LOOP_MSG[]="KeyWord_WarteFolgennummer0                                                                                                     "
   $LOOP_CONT=TRUE
   IF (VW_INB AND $EXTSTARTTYP) THEN
      RETURN
   ENDIF
   REPEAT
      WAIT SEC 0.04
      OUT_WSLAV=TRUE
      OUT_WPROZ=FALSE
   UNTIL (PRG_NR==0) OR ( NOT ($LOOP_CONT) AND (($MODE_OP==#T1) OR ($MODE_OP==#T2)))
   $LOOP_CONT=TRUE
   OUT_WSLAV=FALSE
   OUT_WPROZ=FALSE
   $LOOP_MSG[]="                                                                                                                                "
   IF (VW_CBY_CELL) OR (($MODE_OP<>#T1) AND ($MODE_OP<>#T2)) THEN
      PRG_NR_REFL = 0
   ENDIF
   $OUT[LPKT]=FALSE
   IF VW_INB AND (($MODE_OP==#T1) OR ($MODE_OP==#T2)) THEN
      HALT
   ENDIF
   WAIT SEC 0.04
END
DEF  SUB_ZANGE ( )
  DECL INT SEGMENT,TEILNEHMER
  DECL BOOL TEMP_BOOL,MODE_IBS_ON,MODE_IBS_OFF,TEMP_NEGATION,CloseOutputReserved, OpenOutputReserved
  DECL INT TEMP_ZANGEN_FUNKT
  DECL IBS_MODE_TYP IBSMODE	
  DECL INT TEMP_TYP,TEMP_TYP_NR
  DECL KrlMsg_T Msg
  DECL KrlMsgPar_T Par[3]
  DECL KrlMsgOpt_T Opt
  DECL INT nHandle
   TEMP_TYP=0
   TEMP_ZANGEN_FUNKT=0
   OpenOutputReserved = FALSE
   CloseOutputReserved = FALSE
   IF (ZANGEN_FUNKT==1) THEN
      ;Zange oeffnen
	  TEMP_ZANGEN_FUNKT=ZANGEN_FUNKT
      TEMP_TYP=COND_ZANGE_OPEN[AKT_ZANGE].TYP
      TEMP_TYP_NR=COND_ZANGE_OPEN[AKT_ZANGE].TYP_NR
      TEMP_NEGATION=COND_ZANGE_OPEN[AKT_ZANGE].NEGATION
   ENDIF
   IF (ZANGEN_FUNKT==2) THEN
      ;Zange schliessen
      TEMP_ZANGEN_FUNKT=ZANGEN_FUNKT
      TEMP_TYP=COND_ZANGE_CLOSE[AKT_ZANGE].TYP
      TEMP_TYP_NR=COND_ZANGE_CLOSE[AKT_ZANGE].TYP_NR
      TEMP_NEGATION=COND_ZANGE_CLOSE[AKT_ZANGE].NEGATION
   ENDIF
   SWITCH TEMP_TYP	
    CASE 1
	    ;immer ausfuehren
    CASE 2      
	    ;nie ausfuehren
      ZANGEN_FUNKT=0
      Msg = {Modul[] "TPVW", Nr 202, Msg_txt[] "ZangenCondFalse"}
      Opt = {VL_Stop TRUE, Clear_P_Reset TRUE, Log_To_DB FALSE}
      nHandle = Set_KrlMsg (#Notify, Msg, Par[], Opt)
      RETURN
    CASE 3
      IF $IN[TEMP_TYP_NR] == TEMP_NEGATION THEN
        SEND_MSG (TEMP_TYP, TEMP_NEGATION, TEMP_TYP_NR)
        RETURN
      ENDIF
    CASE 4
      IF $OUT[TEMP_TYP_NR] == TEMP_NEGATION THEN
        SEND_MSG (TEMP_TYP, TEMP_NEGATION, TEMP_TYP_NR)
        RETURN
      ENDIF
    CASE 5
      IF $CYCFLAG[TEMP_TYP_NR] == TEMP_NEGATION THEN
        SEND_MSG (TEMP_TYP, TEMP_NEGATION, TEMP_TYP_NR)
        RETURN
      ENDIF
    CASE 6
      IF $FLAG[TEMP_TYP_NR] == TEMP_NEGATION THEN
        SEND_MSG (TEMP_TYP, TEMP_NEGATION, TEMP_TYP_NR)
        RETURN
      ENDIF
    CASE 7
      IF $TIMER_FLAG[TEMP_TYP_NR] == TEMP_NEGATION THEN
        SEND_MSG (TEMP_TYP, TEMP_NEGATION, TEMP_TYP_NR)
        RETURN
      ENDIF
    CASE 8
      IF S[TEMP_TYP_NR] == TEMP_NEGATION THEN
        SEND_MSG (TEMP_TYP, TEMP_NEGATION, TEMP_TYP_NR)
        RETURN
      ENDIF
    ENDSWITCH
   IF (DEF_ZANGE[AKT_ZANGE].TYP == 6) THEN
      If FL_GUN_FCT THEN
       IF(NOT (IsOutputsReserved())) THEN 
         IF (DEF_ZANGE[AKT_ZANGE].A_AUF > 0) THEN
            ;I/O servo gun open start/stop (Cositronic)
            $OUT[DEF_ZANGE[AKT_ZANGE].A_AUF]=GUN_OPEN
         ENDIF
         IF (DEF_ZANGE[AKT_ZANGE].A_ZU > 0) THEN
            ;I/O servo gun close Start/stop (Cositronic)
            $OUT[DEF_ZANGE[AKT_ZANGE].A_ZU]=GUN_CLOSE
         ENDIF
       ENDIF
         FL_GUN_FCT=FALSE
      ENDIF
   ELSE
      IF ((GUN_CLOSE) OR (GUN_OPEN)) THEN
       IF( NOT (IsOutputsReserved())) THEN 
         IF (DEF_ZANGE[AKT_ZANGE].A_AUF > 0) THEN
            $OUT[DEF_ZANGE[AKT_ZANGE].A_AUF]=FALSE
         ENDIF
         IF (DEF_ZANGE[AKT_ZANGE].A_ZU > 0)THEN
            $OUT[DEF_ZANGE[AKT_ZANGE].A_ZU]=FALSE
         ENDIF
       ENDIF
	  ENDIF
      GUN_CLOSE=FALSE
      GUN_OPEN=FALSE

   ENDIF
   IF ((ZANGEN_FUNKT<=0) OR ($PRO_MOVE) OR ($MODE_OP==#INVALID)) THEN
      ZANGEN_FUNKT=0
      RETURN
   ENDIF
   ;I-BUS-Berechnungen
   SEGMENT=DEF_IBSZANGE[AKT_ZANGE].SEGMENT
   TEILNEHMER=DEF_IBSZANGE[AKT_ZANGE].TEILNEHMER
   IBSMODE=DEF_IBSZANGE[AKT_ZANGE].IBS_MODE
   ;I-BUS-Anschaltung
   MODE_IBS_OFF=FALSE
   MODE_IBS_ON=FALSE
   IF (DEF_ZANGE[AKT_ZANGE].TYP==3) OR (DEF_ZANGE[AKT_ZANGE].TYP==4) THEN
      IF (SEGMENT==0) AND (TEILNEHMER==0) THEN
         MODE_IBS_OFF=TRUE
      ELSE
         ;IF ($IBUS_ON<>((SEGMENT*256)+TEILNEHMER)) THEN ;Fehlerbehebung 46025
            MODE_IBS_ON=TRUE
         ;ENDIF
      ENDIF
   ENDIF
   ;eigentliche I-BUS-Anschaltung
   IF MODE_IBS_ON THEN
      TEMP_BOOL=SET_IBS(SEGMENT,TEILNEHMER)
      ZANGEN_FUNKT=0
      RETURN
   ENDIF
   IF ((MODE_IBS_OFF) AND (IBSMODE==#PREE_OFF)) THEN
      TEMP_BOOL=RESET_IBS(SEGMENT,TEILNEHMER)
   ENDIF
   ;Bedienung der Zange-AUF/ZU-Tasten (SPS.SUB)
   IF (TEMP_ZANGEN_FUNKT==1) THEN
      ;Zange oeffnen
      IF( NOT (IsOutputsReserved())) THEN
      VW (#GUN,TRUE,AKT_ZANGE,1 )
      ENDIF
   ENDIF
   IF (TEMP_ZANGEN_FUNKT==2) THEN
      IF (NOT(IsOutputsReserved())) THEN
      ;Zange schliessen
      VW (#GUN,TRUE,AKT_ZANGE,0 )
      ENDIF
   ENDIF
   ZANGEN_FUNKT=0
   ;Ende der Bedienung Zange-AUF/ZU-Tasten (SPS.SUB)
   ;nachtraegliche I-BUS-Abschaltung
   IF ((MODE_IBS_OFF) AND (IBSMODE==#PAST_OFF)) THEN
      WAIT SEC PULS_TIME
      TEMP_BOOL=RESET_IBS(SEGMENT,TEILNEHMER)
   ENDIF
END
DEFFCT BOOL IsOutputsReserved()
BOOL IsReserved, isOpenIndexSystemOutput, isCloseIndexSystemOutput
IsReserved = FALSE 
IF(DEF_ZANGE[AKT_ZANGE].A_AUF >0) THEN
     isOpenIndexSystemOutput = ($IOSIM_OUT[DEF_ZANGE[AKT_ZANGE].A_AUF] == "0") OR ($IOSIM_OUT[DEF_ZANGE[AKT_ZANGE].A_AUF] == "1") OR ($IOSIM_OUT[DEF_ZANGE[AKT_ZANGE].A_AUF] == "3") OR ($IOSIM_OUT[DEF_ZANGE[AKT_ZANGE].A_AUF] == "4")
   IF(NOT(isOpenIndexSystemOutput)) THEN
      MsgNotify("WrongOpenGunOutputIndex", "Gripper",DEF_ZANGE[AKT_ZANGE].A_AUF , , 5)
      IsReserved = TRUE
   ENDIF
ENDIF
IF(DEF_ZANGE[AKT_ZANGE].A_ZU >0) THEN
   isCloseIndexSystemOutput= ($IOSIM_OUT[DEF_ZANGE[AKT_ZANGE].A_ZU] == "0") OR ($IOSIM_OUT[DEF_ZANGE[AKT_ZANGE].A_ZU] == "1") OR ($IOSIM_OUT[DEF_ZANGE[AKT_ZANGE].A_ZU] == "3") OR ($IOSIM_OUT[DEF_ZANGE[AKT_ZANGE].A_ZU] == "4")
   IF(NOT (isCloseIndexSystemOutput)) THEN
      MsgNotify("WrongCloseGunOutputIndex", "Gripper",DEF_ZANGE[AKT_ZANGE].A_ZU , , 6)
      IsReserved = TRUE
   ENDIF
   ENDIF
   IF(IsReserved) THEN
      RETURN TRUE
   ENDIF
 RETURN FALSE
ENDFCT
DEF SEND_MSG(TYP:IN, NEGATION:IN, NUMBER:IN)		
  DECL INT TYP, NUMBER, OFFSET, RESULT
  DECL BOOL NEGATION
  DECL KrlMsg_T Msg
  DECL KrlMsgPar_T Par[3]
  DECL KrlMsgOpt_T Opt
  DECL INT nHandle
  DECL STATE_T STATE
  CHAR MsgString[30]
  IF NEGATION THEN
    MsgString[]="!"
  ENDIF
  SWITCH TYP	
    CASE 3
      RESULT=StrAdd(MsgString[],"E[%d] = TRUE")
    CASE 4
      RESULT=StrAdd(MsgString[],"A[%d] = TRUE")
    CASE 5
      RESULT=StrAdd(MsgString[],"M[%d] = TRUE")
    CASE 6
      RESULT=StrAdd(MsgString[],"F[%d] = TRUE")
    CASE 7
      RESULT=StrAdd(MsgString[],"T[%d] = TRUE")
    CASE 8
      RESULT=StrAdd(MsgString[],"S[%d] = TRUE")
  ENDSWITCH
  ZANGEN_FUNKT=0  
  OFFSET=0
  Msg = {Modul[] "TPVW", Nr 203, Msg_txt[] "ZangenCondNotTrue"}  
  Par[1].Par_type=#Value
  Par[1].Par_txt[]=","
  SWRITE(Par[1].Par_txt[], STATE, OFFSET, MsgString[], NUMBER)
  Opt = {VL_Stop TRUE, Clear_P_Reset TRUE, Log_To_DB FALSE}
  nHandle = Set_KrlMsg (#Notify, Msg, Par[], Opt)
END
DEF  WEAVE_INIT ( )
   ;mechanical weaving
   IF $TECH_OPT==TRUE THEN
      A_LAST_FILT=$DEF_FLT_PTP
      $TECH[1].CLASS=#PATH
      $TECH[1].FCTCTRL.OFFSET_IN=0
      $TECH[1].FCTCTRL.OFFSET_OUT=0
      $TECH[1].MODE=#OFF
      $TECH[2].CLASS=#PATH
      $TECH[2].FCTCTRL.OFFSET_IN=0
      $TECH[2].FCTCTRL.OFFSET_OUT=0
      $TECH[2].MODE=#OFF
      ;thermic weaving
      $TECH[3].CLASS=#PATH
      $TECH[3].FCTCTRL.OFFSET_IN=0
      $TECH[3].FCTCTRL.OFFSET_OUT=0
      $TECH[3].MODE=#OFF
      ;common
      $TECH[1].FCTCTRL.GEOREF=#Y
      $TECH[2].FCTCTRL.GEOREF=#X
      $TECH[3].FCTCTRL.GEOREF=#NONE
      $TECHANGLE.A=0
      $TECHANGLE.B=0
      $TECHANGLE.C=0
      $TECHSYS=#TTS
      $TECH[1].FCTCTRL.SCALE_IN=1
      $TECH[1].FCTCTRL.SCALE_OUT=0
      $TECH[2].FCTCTRL.SCALE_IN=1
      $TECH[2].FCTCTRL.SCALE_OUT=0
      $TECH[3].FCTCTRL.SCALE_IN=1
      $TECH[3].FCTCTRL.SCALE_OUT=1
      $TECHANGLE.C=0
   ENDIF
END
DEF  WEAVING (W_STATE :IN,W_TYP :IN,AMPLITUDE :IN,PERIOD :IN,W_ANGLE :IN )
   BOOL W_STATE ;weaving ON / OFF
   INT W_TYP,AMPLITUDE,PERIOD,W_ANGLE
   IF $TECH_OPT==TRUE THEN
      IF W_STATE==TRUE THEN
         ; weaving will be switched ON
         WEAV_DEF (W_TYP )
         $TECH[1].FCTCTRL.SCALE_IN=PERIOD
         $TECH[1].FCTCTRL.SCALE_OUT=AMPLITUDE
         $TECH[2].FCTCTRL.SCALE_IN=PERIOD
         $TECH[2].FCTCTRL.SCALE_OUT=AMPLITUDE
         $TECH[3].FCTCTRL.SCALE_IN=PERIOD
         $TECH[3].FCTCTRL.SCALE_OUT=1
         $TECHANGLE.C=W_ANGLE
         IF $TECH[1].MODE==#OFF THEN
            $TECH[1].MODE=#CYCLE
            $TECH[2].MODE=#CYCLE
            $TECH[3].MODE=#CYCLE
         ENDIF ;tech_mode
      ELSE
         ; weaving will be switched OFF
         $TECH[1].MODE=#OFF
         $TECH[2].MODE=#OFF
         $TECH[3].MODE=#OFF
      ENDIF ;w_state
   ENDIF ;tech_opt
END
DEF  WEAVING_C (W_STATE :IN,W_TYP :IN,AMPLITUDE :IN,PERIOD :IN,W_ANGLE :IN )
   BOOL W_STATE ;weaving ON / OFF
   INT W_TYP,AMPLITUDE,PERIOD,W_ANGLE
   IF $TECH_OPT==TRUE THEN
      IF W_STATE==TRUE THEN
         ; weaving will be switched ON
         IF $TECH[1].MODE<>#OFF THEN
            $TECH_C[1].FCTCTRL.SCALE_IN=PERIOD
            $TECH_C[1].FCTCTRL.SCALE_OUT=AMPLITUDE
            $TECH_C[2].FCTCTRL.SCALE_IN=PERIOD
            $TECH_C[2].FCTCTRL.SCALE_OUT=AMPLITUDE
            $TECH_C[3].FCTCTRL.SCALE_IN=PERIOD
            $TECH_C[3].FCTCTRL.SCALE_OUT=1
            $TECHANGLE_C.C=W_ANGLE
         ENDIF ;tech_mode
      ELSE
         ; weaving will be switched OFF
         IF $TECH[1].MODE<>#OFF THEN
            $TECH_C[1].MODE=#OFF
            $TECH_C[2].MODE=#OFF
            $TECH_C[3].MODE=#OFF
         ENDIF
      ENDIF ;w_state
   ENDIF ;tech_opt
END
DEF  SP_WEAVING_C (W_STATE :IN,W_TYP :IN,AMPLITUDE :IN,PERIOD :IN,W_ANGLE :IN )
	BOOL W_STATE ;weaving ON / OFF
	INT W_TYP,AMPLITUDE,PERIOD,W_ANGLE
	IF $TECH_OPT==TRUE THEN
		IF W_STATE==TRUE THEN
			;Set Figur and initialize
			SPLINE_WEAV_DEF (W_TYP)
			; weaving will be switched ON
            $SPL_TECH_C[1].FCTCTRL.SCALE_OUT = AMPLITUDE
            $SPL_TECH_C[2].FCTCTRL.SCALE_OUT = AMPLITUDE
            $SPL_TECH_C[3].FCTCTRL.SCALE_OUT = AMPLITUDE
            $SPL_TECH_C[1].FCTCTRL.SCALE_IN = PERIOD
            $SPL_TECH_C[2].FCTCTRL.SCALE_IN = PERIOD
            $SPL_TECH_C[3].FCTCTRL.SCALE_IN = PERIOD
            WHILE (W_ANGLE>180.0)
               W_ANGLE= -(360.0-W_ANGLE)
            ENDWHILE
            WHILE (W_ANGLE<-180.0)
               W_ANGLE=-(360.0+W_ANGLE)
            ENDWHILE
			;Function generators are limitted to range +/- 179.99 degrees   
            IF (ABS(W_ANGLE)>=180.0)THEN
               IF (W_ANGLE>0)THEN
                  W_ANGLE=179.9
                 ELSE
                  W_ANGLE= -179.9
               ENDIF
            ENDIF
            ;#SetParameterInMainTask
            $SPL_TECH_C[1].REF_SYS.ANGLES.A=0.0
            $SPL_TECH_C[1].REF_SYS.ANGLES.B=0.0
            $SPL_TECH_C[1].REF_SYS.ANGLES.C=W_ANGLE
            $SPL_TECH_C[2].REF_SYS.ANGLES.A=0.0
            $SPL_TECH_C[2].REF_SYS.ANGLES.B=0.0
            $SPL_TECH_C[2].REF_SYS.ANGLES.C=W_ANGLE
            $SPL_TECH_C[3].REF_SYS.ANGLES.A=0.0
            $SPL_TECH_C[3].REF_SYS.ANGLES.B=0.0
            $SPL_TECH_C[3].REF_SYS.ANGLES.C=W_ANGLE
			$SPL_TECH_C[1].MODE=#CYCLE
			SWITCH FIGUR
				CASE 4
					$SPL_TECH_C[2].MODE=#CYCLE
				CASE 5,6,7
					$SPL_TECH_C[2].MODE=#CYCLE
					$SPL_TECH_C[3].MODE=#CYCLE
				DEFAULT        
			ENDSWITCH
		ELSE
			; weaving will be switched OFF
			IF $SPL_TECH_C[1].MODE<>#OFF THEN
				$SPL_TECH_C[1].MODE=#OFF
				$SPL_TECH_C[2].MODE=#OFF
				$SPL_TECH_C[3].MODE=#OFF
			ENDIF
		ENDIF ;w_state
	ENDIF ;tech_opt
END
; standard cancel Routine
DEF  SPS_P_FREE ( )
   ; reset WPROZ, WSLAV
   INT INT_N
   INT10=FALSE
   OUT_WPROZ=FALSE
   OUT_WSLAV=FALSE
   ;Zuruecksetzen der aktiven Verriegelungen
   $CYCFLAG[255]=TRUE  ;reset, da andernfalls $out[0] eine Bedingung werden koennte --> Fehler im EXPR_INT...
   FOR INT_N=1 TO  8
      IF ((VW_VERR[INT_N].OUT<>0) AND (VW_VERR[INT_N].IN<>$IOSYS_IN_TRUE)) THEN
         $OUT[VW_VERR[INT_N].OUT]=FALSE
      VW_VERR[INT_N].IN=$IOSYS_IN_TRUE
      ENDIF
      VW_VERR[INT_N].OUT=0
   ENDFOR
   WRITE_VERR_COND (TRUE)   
   $TIMER[61]=0
   $TIMER_STOP[61]=TRUE
   ; reset messages
   $LOOP_MSG[]="                                                                                                                                "
   ; reset SPS_CALL
   SPS_N=-1
   ; reset PF0-Merker
   P0_MERKER=FALSE
   PRG_NR_REFL = 0
   CALLBYSELECT=FALSE
END
DEF  SPS_P_RESET ( )
   ; reset WPROZ, WSLAV
   INT INT_N
   INT10=FALSE
   OUT_WPROZ=FALSE
   OUT_WSLAV=FALSE
   ;Zuruecksetzen der aktiven Verriegelungen
   $CYCFLAG[255]=TRUE  ;reset, da andernfalls $out[0] eine Bedingung werden koennte --> Fehler im EXPR_INT...
   WAIT SEC 0.024
   FOR INT_N=1 TO  8
      IF ((VW_VERR[INT_N].OUT<>0) AND (VW_VERR[INT_N].IN<>$IOSYS_IN_TRUE)) THEN
         $OUT[VW_VERR[INT_N].OUT]=FALSE
         VW_VERR[INT_N].IN=$IOSYS_IN_TRUE
      ENDIF
      VW_VERR[INT_N].OUT=0
   ENDFOR
   WRITE_VERR_COND (TRUE)   
   VW_CBY_CELL=FALSE
   $TIMER[61]=0
   $TIMER_STOP[61]=TRUE
   $LOOP_MSG[]="                                                                                                                                "
   SPS_N=-1
   P0_MERKER=FALSE
   ; write P_SELECT
   LAST_PRO_NR ( )
   CALLBYSELECT=FALSE
END
; gets the last selected Programm-Number
DEF  LAST_PRO_NR ( )
   DECL STATE_T STATE
   DECL CHAR PRO_NAME1_L[24]
   INT OFFSET
   PRO_NAME1_L[]="                        "
   OFFSET=0
   WAIT SEC 0.024
   SWRITE(PRO_NAME1_L[],STATE,OFFSET,$PRO_NAME1[],0)
   IF (PRO_NAME1_L[1]=="F") AND (PRO_NAME1_L[2]=="O") AND (PRO_NAME1_L[3]=="L") AND (PRO_NAME1_L[4]=="G") AND (PRO_NAME1_L[5]=="E") THEN
      OFFSET=5
      SREAD($PRO_NAME1[],STATE,OFFSET,"%D",P_SELECT)
   ENDIF
END
DEF  SPSMOVEBCO ( )
   $TIMER[61]=-250
   $TIMER_STOP[61]=FALSE
   INTERRUPT ENABLE 10
END
DEF  VW_VERR_EIN (NR :IN,IN_NR :IN,OUT_NR :IN,V_PRIO :IN )
   INT NO,NR,IN_NR,OUT_NR,V_PRIO,OFFSET
   DECL STATE_T STATE
   NO=0
   IF VW_VERR[NR].IN<>$IOSYS_IN_TRUE THEN
      CONTINUE
      $LOOP_CONT=TRUE
      $LOOP_MSG[]="KeyWord_WaitForVerrOff                                                                                                   "
      WAIT FOR  ((VW_VERR[NR].IN==$IOSYS_IN_TRUE) OR ( NOT $LOOP_CONT AND ($MODE_OP<>#EX)))
      $LOOP_MSG[]="                                                                                                                                "
   ENDIF
   VW_VERR[NR].NAME[]="       "
   CONTINUE
   SWRITE(VW_VERR[NR].NAME[],STATE,NO,TEMP_E[],IN_NR)
   $LOOP_MSG[]="                                                                                                                                "
   OFFSET=0
   CONTINUE
   SWRITE($LOOP_MSG[],STATE,OFFSET,VW_VERR[NR].NAME[],0)
   $LOOP_CONT=TRUE
   CONTINUE
   WHILE   NOT ($IN[IN_NR] OR ( NOT $LOOP_CONT AND ($MODE_OP<>#EX)))
      IF ($LOOP_MSG[1]==" ") AND ($LOOP_MSG[2]==" ") THEN
         OFFSET=0
         CONTINUE
         SWRITE($LOOP_MSG[],STATE,OFFSET,VW_VERR[NR].NAME[],0)
         CONTINUE
         WAIT SEC 0.05
      ENDIF
   ENDWHILE
   CONTINUE
   IF  NOT $LOOP_CONT THEN
      IN_NR=$IOSYS_IN_TRUE
      VW_VERR[NR].NAME[]="SIMU   "
   ENDIF
   $LOOP_CONT=TRUE
   CONTINUE
   $OUT[OUT_NR]=FALSE
   IF V_PRIO>1 THEN
      CONTINUE
      WAIT SEC 0.08
      CONTINUE
      IF  NOT $IN[IN_NR] THEN
         CONTINUE
         $OUT[OUT_NR]=TRUE
         $LOOP_CONT=TRUE
         CONTINUE
         WHILE   NOT ($IN[IN_NR] OR ( NOT $LOOP_CONT AND ($MODE_OP<>#EX)))
            IF ($LOOP_MSG[1]==" ") AND ($LOOP_MSG[2]==" ") THEN
               OFFSET=0
               CONTINUE
               SWRITE($LOOP_MSG[],STATE,OFFSET,VW_VERR[NR].NAME[],0)
               CONTINUE
               WAIT SEC 0.05
            ENDIF
         ENDWHILE
         CONTINUE
         IF  NOT $LOOP_CONT THEN
            IN_NR=$IOSYS_IN_TRUE
            VW_VERR[NR].NAME[]="SIMU   "
         ENDIF
         $LOOP_CONT=TRUE
         CONTINUE
         $OUT[OUT_NR]=FALSE
      ENDIF
   ENDIF
   VW_VERR[NR].IN=IN_NR
   VW_VERR[NR].OUT=OUT_NR
   $LOOP_MSG[]="                                                                                                                                "
   WRITE_VERR_COND (FALSE)
   IF $ACT_ADVANCE<1 THEN
	$VW_RETRACE_AMF=TRUE
   ENDIF
END
DEF  VW_VERR_AUS (NR :IN )
   INT NR
   VW_VERR[NR].IN=$IOSYS_IN_TRUE ;Ueberwachung abschalten
   WRITE_VERR_COND (TRUE)  ;$CYCFLAG[255] neu aufbauen
   IF VW_VERR[NR].OUT>0 THEN
      $OUT[VW_VERR[NR].OUT]=TRUE ;Verriegelungsausgang setzen
   ENDIF
   VW_VERR[NR].NAME[]="       "
END
DEF  IBS_ALTERNAT (SEGMENT :IN,TEILNEHMER :IN,S_MODE :IN )
   DECL STATE_T STATE
   INT OFFSET,SEGMENT,TEILNEHMER
   BOOL S_MODE
   OFFSET=0
   ; Bussegment einschalten
   IF  NOT SET_IBS(SEGMENT,TEILNEHMER) THEN
      SWRITE($LOOP_MSG[],STATE,OFFSET,"ERROR IBUS_ON  %D.",SEGMENT)
      SWRITE($LOOP_MSG[],STATE,OFFSET,"%D",TEILNEHMER)
      $LOOP_CONT=TRUE
      WAIT FOR  ($IBUS_ON==(SEGMENT*256)+TEILNEHMER)  OR ( NOT $LOOP_CONT AND ($MODE_OP<>#EX))
      $LOOP_MSG[]="                                                                                                                                "
   ENDIF
   IF NOT S_MODE THEN
      ; Bussegment ausschalten
      IF  NOT RESET_IBS(SEGMENT,TEILNEHMER) THEN
         SWRITE($LOOP_MSG[],STATE,OFFSET,"ERROR IBUS_OFF  %D.",SEGMENT)
         SWRITE($LOOP_MSG[],STATE,OFFSET,"%D",TEILNEHMER)
         $LOOP_CONT=TRUE
         WAIT FOR  ($IBUS_OFF>0)  OR ( NOT $LOOP_CONT AND ($MODE_OP<>#EX))
         $LOOP_MSG[]="                                                                                                                                "
      ENDIF
   ENDIF
END
DEF VW_PULSE (TYP: IN,TYP_NR: IN,I_TIME :IN,OUT_NR: IN,NEGATION :IN)
    BOOL NEGATION
    INT TYP,TYP_NR,I_TIME,OUT_NR
    SWITCH TYP
    CASE 1
        IF ($OUT[OUT_NR]==FALSE) THEN
           PULSE($OUT[OUT_NR],TRUE,I_TIME/10.0)
        ENDIF
    CASE 2
        IF ($OUT[OUT_NR]==TRUE) THEN
           PULSE($OUT[OUT_NR],FALSE,I_TIME/10.0)
        ENDIF
    CASE 3
        IF NEGATION THEN
            IF NOT ($OUT[OUT_NR]==$IN[TYP_NR]) THEN
               PULSE($OUT[OUT_NR],$IN[TYP_NR],I_TIME/10.0)
            ENDIF
        ELSE
            IF ($OUT[OUT_NR]==$IN[TYP_NR]) THEN
               PULSE($OUT[OUT_NR],NOT $IN[TYP_NR],I_TIME/10.0)
            ENDIF
        ENDIF
    CASE 4
        IF NEGATION THEN
            IF NOT ($OUT[OUT_NR]==$OUT[TYP_NR]) THEN
               PULSE($OUT[OUT_NR],$OUT[TYP_NR],I_TIME/10.0)
            ENDIF
        ELSE
            IF ($OUT[OUT_NR]==$OUT[TYP_NR]) THEN
               PULSE($OUT[OUT_NR],NOT $OUT[TYP_NR],I_TIME/10.0)
            ENDIF
        ENDIF
    CASE 5
        IF NEGATION THEN
            IF NOT ($OUT[OUT_NR]==$CYCFLAG[TYP_NR]) THEN
               PULSE($OUT[OUT_NR],$CYCFLAG[TYP_NR],I_TIME/10.0)
            ENDIF
        ELSE
            IF ($OUT[OUT_NR]==$CYCFLAG[TYP_NR]) THEN
               PULSE($OUT[OUT_NR],NOT $CYCFLAG[TYP_NR],I_TIME/10.0)
            ENDIF
        ENDIF
    CASE 6
        IF NEGATION THEN
            IF NOT ($OUT[OUT_NR]==$FLAG[TYP_NR]) THEN
               PULSE($OUT[OUT_NR],$FLAG[TYP_NR],I_TIME/10.0)
            ENDIF
        ELSE
            IF ($OUT[OUT_NR]==$FLAG[TYP_NR]) THEN
               PULSE($OUT[OUT_NR],NOT $FLAG[TYP_NR],I_TIME/10.0)
            ENDIF
        ENDIF
    CASE 7
        IF NEGATION THEN
            IF NOT ($OUT[OUT_NR]==$TIMER_FLAG[TYP_NR]) THEN
               PULSE($OUT[OUT_NR],$TIMER_FLAG[TYP_NR],I_TIME/10.0)
            ENDIF
        ELSE
            IF ($OUT[OUT_NR]==$TIMER_FLAG[TYP_NR]) THEN
               PULSE($OUT[OUT_NR],NOT $TIMER_FLAG[TYP_NR],I_TIME/10.0)
            ENDIF
        ENDIF
    CASE 8
        IF NEGATION THEN
            IF NOT ($OUT[OUT_NR]==S[TYP_NR]) THEN
               PULSE($OUT[OUT_NR],S[TYP_NR],I_TIME/10.0)
            ENDIF
        ELSE
            IF ($OUT[OUT_NR]==S[TYP_NR]) THEN
               PULSE($OUT[OUT_NR],NOT S[TYP_NR],I_TIME/10.0)
            ENDIF
        ENDIF
    ENDSWITCH
END
DEF VW_SPECIAL_MAKRO (INIT :IN )
   DECL INT RESULT, CheckTime
   DECL STATE_T STAT
   DECL MODUS_T MODE
   BOOL INIT   
   IF ( INIT ) THEN
      ;reset special makro variables
      SpecialRunStartFlag = FALSE 
      SpecialRunEndFlag = FALSE    
      SpecialRunStartTrig = FALSE 
      SpecialRunEndTrig = FALSE 
      SPECIALRUNFINISHED=FALSE
      STARTSPECIALRUN=FALSE
      TimeSpecialRunStart = 0
      IF (TIMEOUTSPECIALRUN <= 0) THEN
         MSGNOTIFY("SpecialMakroTimeoutConfigError", "VwInlineForms",TIMEOUTSPECIALRUN,,107)
         TIMEOUTSPECIALRUN = 1000
      ENDIF
      IF ((MAKRONUMBERSPECIALRUN < 0) OR (MAKRONUMBERSPECIALRUN > 999)) THEN
         MSGNOTIFY("SpecialMakroNumberConfigError", "VwInlineForms",MAKRONUMBERSPECIALRUN,,108)
         RETURN
      ENDIF
      ;start special makro at restart
      STARTSPECIALRUN=TRUE
      RETURN
   ENDIF   
   MODE=#SYNC
   ;select program sps7()
   ;to start the program the START-button or
   ;an external start-signal is needed
   IF STARTSPECIALRUN==FALSE THEN
      SpecialRunStartFlag = FALSE 
   ENDIF
   IF SPECIALRUNFINISHED==FALSE THEN 
      SpecialRunEndFlag = FALSE  
   ENDIF
   IF ((STARTSPECIALRUN==TRUE) AND (SpecialRunStartFlag==FALSE)) THEN
      IF (SPECIALRUNMAKROAVAILABLE==TRUE) THEN
         SpecialRunStartFlag = TRUE
         SpecialRunStartTrig = TRUE
      ELSE      
         MsgNotifyLogToDB("SpecialMakroNumberNotAvailableError", "VwInlineForms",MAKRONUMBERSPECIALRUN,,110)
      ENDIF
      STARTSPECIALRUN = FALSE
   ENDIF
   IF ((SPECIALRUNFINISHED==TRUE) AND (SpecialRunEndFlag==FALSE)) THEN
      SpecialRunEndFlag = TRUE
      SpecialRunEndTrig = TRUE
   ENDIF
   IF SpecialRunStartTrig THEN
      CWRITE($CMD,STAT,MODE,"RUN /R1/SPS7() > 9")
      IF (STAT.RET1 == #CMD_OK) THEN
         WAIT FOR $PROG_INFO[9].P_STATE == #P_ACTIVE
         TimeSpecialRunStart = $ROB_TIMER
         SpecialRunStartTrig = FALSE 
     ELSE      
        MSGNOTIFY("SpecialMakroCallError", "VwInlineForms", MAKRONUMBERSPECIALRUN,,111)
        SpecialRunStartTrig = FALSE 
     ENDIF 
   ENDIF
   ; check timeout
   IF (TimeSpecialRunStart <> 0) THEN
      CheckTime = $ROB_TIMER - TimeSpecialRunStart      
      ;handle overflow of $ROB_TIMER
      IF (CheckTime < 0) THEN
         ; invert sign
         TimeSpecialRunStart = TimeSpecialRunStart - 2147483647
      ENDIF      
      IF (CheckTime >= TIMEOUTSPECIALRUN) THEN
         MsgNotifyLogToDB("SpecialMakroRunError", "VwInlineForms",MAKRONUMBERSPECIALRUN,,106)
         TimeSpecialRunStart = 0
         $LOOP_MSG[]="                                                                                                                                "
         SPECIALRUNFINISHED = TRUE
      ENDIF
   ENDIF   
   ;cancel program sps7()
   IF SpecialRunEndTrig THEN
      IF ($PROG_INFO[9].P_STATE <> #P_FREE) THEN
         CWRITE($CMD,STAT,MODE,"STOP 9")
         IF (STAT.RET1 == #CMD_ABORT) THEN
             MSGNOTIFY("SpecialMakroAbortError", "VwInlineForms", MAKRONUMBERSPECIALRUN,,112)
         ELSE
            WAIT FOR ($PROG_INFO[9].P_STATE == #P_STOP)
            CWRITE($CMD,STAT,MODE,"CANCEL 9")
         ENDIF
      ENDIF
      IF ($PROG_INFO[9].P_STATE == #P_FREE) THEN
         TimeSpecialRunStart = 0
         SpecialRunEndTrig = FALSE
      ENDIF
      SPECIALRUNFINISHED=FALSE 
   ENDIF   
END
DEFFCT  BOOL SET_IBS(SEGM :IN,TEILN :IN)
   ; setzen eines alternativen Bussegmentes
   INT DEZ_VALUE,SEGM,TEILN
   INT TEMP_IBS
   DEZ_VALUE=(SEGM*256)+TEILN
   $IBUS_OFF=0
   IF $IBUS_ON>0 THEN
      TEMP_IBS=$IBUS_ON
      $IBUS_ON=0
      $IBUS_OFF=TEMP_IBS
      IF $IBUS_OFF<0 THEN
         LAST_IBS_PRO.ON=$IBUS_ON
         RETURN  (FALSE)
      ENDIF
   ENDIF
   $IBUS_ON=DEZ_VALUE
   IF $IBUS_ON<>DEZ_VALUE THEN
      LAST_IBS_PRO.ON=$IBUS_ON
      RETURN  (FALSE)
   ELSE
      LAST_IBS_PRO.ON=$IBUS_ON
      RETURN  (TRUE)
   ENDIF
ENDFCT
DEFFCT  BOOL RESET_IBS(SEGM :OUT,TEILN :OUT)
   ; ruecksetzen eines alternativen Bussegmentes
   INT SEGM,TEILN
   INT TEMP_IBS
   TEILN=$IBUS_ON B_AND 'HFF'
   SEGM=($IBUS_ON B_AND 'HFF00')/256
   IF $IBUS_ON>0 THEN
      TEMP_IBS=$IBUS_ON
      $IBUS_ON=0
      $IBUS_OFF=0
      $IBUS_OFF=TEMP_IBS
      IF $IBUS_OFF<0 THEN
         RETURN  (FALSE)
      ELSE
         LAST_IBS_PRO.OFF=$IBUS_OFF
         RETURN  (TRUE)
      ENDIF
   ELSE
      $IBUS_ON=0
      $IBUS_OFF=0
      $IBUS_OFF=LAST_IBS_PRO.ON
      IF $IBUS_OFF>0 THEN
         LAST_IBS_PRO.OFF=$IBUS_OFF
         RETURN  (TRUE)
      ELSE
         RETURN  (FALSE)
      ENDIF
   ENDIF
ENDFCT
DEF  CHECK_IBS ( )
   IF LAST_IBS_PRO.STATE THEN
      IF $IBUS_ON==LAST_IBS_PRO.ON THEN
         RETURN
      ELSE
         IF $PRO_MOVE THEN
            BRAKE
         ENDIF
         $LOOP_CONT=TRUE
         $LOOP_MSG[]="KeyWord_CheckInterBus                                                                                                 "
         WAIT FOR  ($IBUS_ON==LAST_IBS_PRO.ON) OR ( NOT $LOOP_CONT AND ($MODE_OP<>#EX))
         $LOOP_MSG[]="                                                                                                                                "
      ENDIF
   ELSE
      IF $IBUS_OFF==LAST_IBS_PRO.OFF THEN
         RETURN
      ELSE
         IF $PRO_MOVE THEN
            BRAKE
         ENDIF
         $LOOP_CONT=TRUE
         $LOOP_MSG[]="KeyWord_CheckInterBus                                                                                                   "
         WAIT FOR  ($IBUS_OFF==LAST_IBS_PRO.OFF) OR ( NOT $LOOP_CONT AND ($MODE_OP<>#EX))
         $LOOP_MSG[]="                                                                                                                                "
      ENDIF
   ENDIF
   $LOOP_CONT=TRUE
END
DEF  IS_CELL ( )
   DECL STATE_T STATE
   DECL CHAR PRO_NAME1_L[24]
   INT OFFSET
   PRO_NAME1_L[]="                        "
   OFFSET=0
   SWRITE(PRO_NAME1_L[],STATE,OFFSET,$PRO_NAME1[],0)
   IF (PRO_NAME1_L[1]=="C") AND (PRO_NAME1_L[2]=="E") AND (PRO_NAME1_L[3]=="L") AND (PRO_NAME1_L[4]=="L") THEN
      VW_CBY_CELL=TRUE
   ELSE
      VW_CBY_CELL=FALSE
   ENDIF
END
DEF T_INT10 ( )
  DECL KrlMsg_T Msg
  DECL KrlMsgPar_T Par[3]
  DECL KrlMsgOpt_T Opt
  INT nHandle
  Msg = {Modul[] "TPVW", Nr 204, Msg_txt[] "NoInit_UseReset"}
  Opt = {VL_Stop TRUE, Clear_P_Reset TRUE, Log_To_DB FALSE}  
  WHILE (NOT INT10 OR not EG_SERVO_INIT)
    nHandle = Set_KrlMsg (#Notify, Msg, Par[], Opt)
    HALT
   ENDWHILE
END
DEF T_SUB ( )   
  DECL KrlMsg_T Msg
  DECL KrlMsgPar_T Par[3]
  DECL KrlMsgOpt_T Opt
  INT nHandle
  IF $PRO_MOVE THEN
    BRAKE
  ENDIF
  Msg = {Modul[] "TPVW", Nr 205, Msg_txt[] "Start_SPS.SUB"}
  Opt = {VL_Stop TRUE, Clear_P_Reset TRUE, Log_To_DB FALSE}  
  WHILE ($PROG_INFO[2].P_STATE<>#P_ACTIVE)
    nHandle = Set_KrlMsg (#Notify, Msg, Par[], Opt)
    HALT
  ENDWHILE
END
DEFFCT  BOOL DETECT_LMS (VERR_NR : OUT, OUT_NR :OUT)
   INT OUT_NR
   INT VERR_NR
   INT N
   IF ($CYCFLAG[255]==FALSE) THEN
      FOR N=1 TO 8
        IF (VW_VERR[N].IN<>$IOSYS_IN_TRUE) THEN
           IF ($OUT[VW_VERR[N].OUT]) THEN
             ;die Verriegelungsfreigabe wurde trotz aktiver Verriegelung auf log. 1 gesetzt
             OUT_NR=VW_VERR[N].OUT
             VERR_NR=N
             RETURN TRUE 
           ENDIF
        ENDIF
      ENDFOR
      RETURN  FALSE
    ELSE
      OUT_NR=0
      VERR_NR=0
      RETURN FALSE
    ENDIF
ENDFCT
DEF WRITE_VERR_COND (SUB_CALL :IN)
   BOOL SUB_CALL
   INT INT_N, ACTIVE_N
     ;Anzahl der aktiven Verriegelungen ermitteln, und in das Feld ACT_VERR_OUT eintragen (Grund: LZD duerfen nicht im Cycflag verknuepft werden)
     ACTIVE_N=0
     FOR INT_N=1 TO  8
        IF VW_VERR[INT_N].IN<>$IOSYS_IN_TRUE THEN
           ACTIVE_N=ACTIVE_N+1
           ACT_VERR_OUT[ACTIVE_N]=VW_VERR[INT_N].OUT
        ENDIF
     ENDFOR
     IF (SUB_CALL) THEN
       SWITCH ACTIVE_N
        CASE 0
           $CYCFLAG[255]=$IN[VW_VERR[1].IN] AND $IN[VW_VERR[2].IN] AND $IN[VW_VERR[3].IN] AND $IN[VW_VERR[4].IN] AND $IN[VW_VERR[5].IN] AND $IN[VW_VERR[6].IN] AND $IN[VW_VERR[7].IN] AND $IN[VW_VERR[8].IN] 
        CASE 1
           $CYCFLAG[255]=$IN[VW_VERR[1].IN] AND $IN[VW_VERR[2].IN] AND $IN[VW_VERR[3].IN] AND $IN[VW_VERR[4].IN] AND $IN[VW_VERR[5].IN] AND $IN[VW_VERR[6].IN] AND $IN[VW_VERR[7].IN] AND $IN[VW_VERR[8].IN] AND NOT($OUT[ACT_VERR_OUT[1]])
        CASE 2
           $CYCFLAG[255]=$IN[VW_VERR[1].IN] AND $IN[VW_VERR[2].IN] AND $IN[VW_VERR[3].IN] AND $IN[VW_VERR[4].IN] AND $IN[VW_VERR[5].IN] AND $IN[VW_VERR[6].IN] AND $IN[VW_VERR[7].IN] AND $IN[VW_VERR[8].IN] AND NOT($OUT[ACT_VERR_OUT[1]]) AND NOT($OUT[ACT_VERR_OUT[2]]) 
        CASE 3
           $CYCFLAG[255]=$IN[VW_VERR[1].IN] AND $IN[VW_VERR[2].IN] AND $IN[VW_VERR[3].IN] AND $IN[VW_VERR[4].IN] AND $IN[VW_VERR[5].IN] AND $IN[VW_VERR[6].IN] AND $IN[VW_VERR[7].IN] AND $IN[VW_VERR[8].IN] AND NOT($OUT[ACT_VERR_OUT[1]]) AND NOT($OUT[ACT_VERR_OUT[2]]) AND NOT($OUT[ACT_VERR_OUT[3]])
        CASE 4
           $CYCFLAG[255]=$IN[VW_VERR[1].IN] AND $IN[VW_VERR[2].IN] AND $IN[VW_VERR[3].IN] AND $IN[VW_VERR[4].IN] AND $IN[VW_VERR[5].IN] AND $IN[VW_VERR[6].IN] AND $IN[VW_VERR[7].IN] AND $IN[VW_VERR[8].IN] AND NOT($OUT[ACT_VERR_OUT[1]]) AND NOT($OUT[ACT_VERR_OUT[2]]) AND NOT($OUT[ACT_VERR_OUT[3]]) AND NOT($OUT[ACT_VERR_OUT[4]]) 
        CASE 5
           $CYCFLAG[255]=$IN[VW_VERR[1].IN] AND $IN[VW_VERR[2].IN] AND $IN[VW_VERR[3].IN] AND $IN[VW_VERR[4].IN] AND $IN[VW_VERR[5].IN] AND $IN[VW_VERR[6].IN] AND $IN[VW_VERR[7].IN] AND $IN[VW_VERR[8].IN] AND NOT($OUT[ACT_VERR_OUT[1]]) AND NOT($OUT[ACT_VERR_OUT[2]]) AND NOT($OUT[ACT_VERR_OUT[3]]) AND NOT($OUT[ACT_VERR_OUT[4]]) AND NOT($OUT[ACT_VERR_OUT[5]]) 
        CASE 6
           $CYCFLAG[255]=$IN[VW_VERR[1].IN] AND $IN[VW_VERR[2].IN] AND $IN[VW_VERR[3].IN] AND $IN[VW_VERR[4].IN] AND $IN[VW_VERR[5].IN] AND $IN[VW_VERR[6].IN] AND $IN[VW_VERR[7].IN] AND $IN[VW_VERR[8].IN] AND NOT($OUT[ACT_VERR_OUT[1]]) AND NOT($OUT[ACT_VERR_OUT[2]]) AND NOT($OUT[ACT_VERR_OUT[3]]) AND NOT($OUT[ACT_VERR_OUT[4]]) AND NOT($OUT[ACT_VERR_OUT[5]]) AND NOT($OUT[ACT_VERR_OUT[6]]) 
        CASE 7
           $CYCFLAG[255]=$IN[VW_VERR[1].IN] AND $IN[VW_VERR[2].IN] AND $IN[VW_VERR[3].IN] AND $IN[VW_VERR[4].IN] AND $IN[VW_VERR[5].IN] AND $IN[VW_VERR[6].IN] AND $IN[VW_VERR[7].IN] AND $IN[VW_VERR[8].IN] AND NOT($OUT[ACT_VERR_OUT[1]]) AND NOT($OUT[ACT_VERR_OUT[2]]) AND NOT($OUT[ACT_VERR_OUT[3]]) AND NOT($OUT[ACT_VERR_OUT[4]]) AND NOT($OUT[ACT_VERR_OUT[5]]) AND NOT($OUT[ACT_VERR_OUT[6]]) AND NOT($OUT[ACT_VERR_OUT[7]]) 
        CASE 8
           $CYCFLAG[255]=$IN[VW_VERR[1].IN] AND $IN[VW_VERR[2].IN] AND $IN[VW_VERR[3].IN] AND $IN[VW_VERR[4].IN] AND $IN[VW_VERR[5].IN] AND $IN[VW_VERR[6].IN] AND $IN[VW_VERR[7].IN] AND $IN[VW_VERR[8].IN] AND NOT($OUT[ACT_VERR_OUT[1]]) AND NOT($OUT[ACT_VERR_OUT[2]]) AND NOT($OUT[ACT_VERR_OUT[3]]) AND NOT($OUT[ACT_VERR_OUT[4]]) AND NOT($OUT[ACT_VERR_OUT[5]]) AND NOT($OUT[ACT_VERR_OUT[6]]) AND NOT($OUT[ACT_VERR_OUT[7]]) AND NOT($OUT[ACT_VERR_OUT[8]])
       ENDSWITCH
     ELSE
       SWITCH ACTIVE_N
        CASE 0
           CONTINUE
           $CYCFLAG[255]=$IN[VW_VERR[1].IN] AND $IN[VW_VERR[2].IN] AND $IN[VW_VERR[3].IN] AND $IN[VW_VERR[4].IN] AND $IN[VW_VERR[5].IN] AND $IN[VW_VERR[6].IN] AND $IN[VW_VERR[7].IN] AND $IN[VW_VERR[8].IN] 
        CASE 1
           CONTINUE
           $CYCFLAG[255]=$IN[VW_VERR[1].IN] AND $IN[VW_VERR[2].IN] AND $IN[VW_VERR[3].IN] AND $IN[VW_VERR[4].IN] AND $IN[VW_VERR[5].IN] AND $IN[VW_VERR[6].IN] AND $IN[VW_VERR[7].IN] AND $IN[VW_VERR[8].IN] AND NOT($OUT[ACT_VERR_OUT[1]])
        CASE 2
           CONTINUE
           $CYCFLAG[255]=$IN[VW_VERR[1].IN] AND $IN[VW_VERR[2].IN] AND $IN[VW_VERR[3].IN] AND $IN[VW_VERR[4].IN] AND $IN[VW_VERR[5].IN] AND $IN[VW_VERR[6].IN] AND $IN[VW_VERR[7].IN] AND $IN[VW_VERR[8].IN] AND NOT($OUT[ACT_VERR_OUT[1]]) AND NOT($OUT[ACT_VERR_OUT[2]]) 
        CASE 3
           CONTINUE
           $CYCFLAG[255]=$IN[VW_VERR[1].IN] AND $IN[VW_VERR[2].IN] AND $IN[VW_VERR[3].IN] AND $IN[VW_VERR[4].IN] AND $IN[VW_VERR[5].IN] AND $IN[VW_VERR[6].IN] AND $IN[VW_VERR[7].IN] AND $IN[VW_VERR[8].IN] AND NOT($OUT[ACT_VERR_OUT[1]]) AND NOT($OUT[ACT_VERR_OUT[2]]) AND NOT($OUT[ACT_VERR_OUT[3]])
        CASE 4
           CONTINUE
           $CYCFLAG[255]=$IN[VW_VERR[1].IN] AND $IN[VW_VERR[2].IN] AND $IN[VW_VERR[3].IN] AND $IN[VW_VERR[4].IN] AND $IN[VW_VERR[5].IN] AND $IN[VW_VERR[6].IN] AND $IN[VW_VERR[7].IN] AND $IN[VW_VERR[8].IN] AND NOT($OUT[ACT_VERR_OUT[1]]) AND NOT($OUT[ACT_VERR_OUT[2]]) AND NOT($OUT[ACT_VERR_OUT[3]]) AND NOT($OUT[ACT_VERR_OUT[4]]) 
        CASE 5
           CONTINUE
           $CYCFLAG[255]=$IN[VW_VERR[1].IN] AND $IN[VW_VERR[2].IN] AND $IN[VW_VERR[3].IN] AND $IN[VW_VERR[4].IN] AND $IN[VW_VERR[5].IN] AND $IN[VW_VERR[6].IN] AND $IN[VW_VERR[7].IN] AND $IN[VW_VERR[8].IN] AND NOT($OUT[ACT_VERR_OUT[1]]) AND NOT($OUT[ACT_VERR_OUT[2]]) AND NOT($OUT[ACT_VERR_OUT[3]]) AND NOT($OUT[ACT_VERR_OUT[4]]) AND NOT($OUT[ACT_VERR_OUT[5]]) 
        CASE 6
           CONTINUE
           $CYCFLAG[255]=$IN[VW_VERR[1].IN] AND $IN[VW_VERR[2].IN] AND $IN[VW_VERR[3].IN] AND $IN[VW_VERR[4].IN] AND $IN[VW_VERR[5].IN] AND $IN[VW_VERR[6].IN] AND $IN[VW_VERR[7].IN] AND $IN[VW_VERR[8].IN] AND NOT($OUT[ACT_VERR_OUT[1]]) AND NOT($OUT[ACT_VERR_OUT[2]]) AND NOT($OUT[ACT_VERR_OUT[3]]) AND NOT($OUT[ACT_VERR_OUT[4]]) AND NOT($OUT[ACT_VERR_OUT[5]]) AND NOT($OUT[ACT_VERR_OUT[6]]) 
        CASE 7
           CONTINUE
           $CYCFLAG[255]=$IN[VW_VERR[1].IN] AND $IN[VW_VERR[2].IN] AND $IN[VW_VERR[3].IN] AND $IN[VW_VERR[4].IN] AND $IN[VW_VERR[5].IN] AND $IN[VW_VERR[6].IN] AND $IN[VW_VERR[7].IN] AND $IN[VW_VERR[8].IN] AND NOT($OUT[ACT_VERR_OUT[1]]) AND NOT($OUT[ACT_VERR_OUT[2]]) AND NOT($OUT[ACT_VERR_OUT[3]]) AND NOT($OUT[ACT_VERR_OUT[4]]) AND NOT($OUT[ACT_VERR_OUT[5]]) AND NOT($OUT[ACT_VERR_OUT[6]]) AND NOT($OUT[ACT_VERR_OUT[7]]) 
        CASE 8
           CONTINUE
           $CYCFLAG[255]=$IN[VW_VERR[1].IN] AND $IN[VW_VERR[2].IN] AND $IN[VW_VERR[3].IN] AND $IN[VW_VERR[4].IN] AND $IN[VW_VERR[5].IN] AND $IN[VW_VERR[6].IN] AND $IN[VW_VERR[7].IN] AND $IN[VW_VERR[8].IN] AND NOT($OUT[ACT_VERR_OUT[1]]) AND NOT($OUT[ACT_VERR_OUT[2]]) AND NOT($OUT[ACT_VERR_OUT[3]]) AND NOT($OUT[ACT_VERR_OUT[4]]) AND NOT($OUT[ACT_VERR_OUT[5]]) AND NOT($OUT[ACT_VERR_OUT[6]]) AND NOT($OUT[ACT_VERR_OUT[7]]) AND NOT($OUT[ACT_VERR_OUT[8]])
       ENDSWITCH
     ENDIF
END
DEF  CHECK_EMI( )
  BOOL EMI_OKAY
  IF (EMI_RECSTATE("VW_ASCII", "IBGN01.IBG") == -2) THEN
     RETURN
  ENDIF 
  $LOOP_CONT=TRUE
  $LOOP_MSG[]="KeyWord_WarteLadenIBGN                                                                                                     "
  REPEAT
   EMI_OKAY=TRUE
   IF ((EMI_RECSTATE("VW_ASCII", "IBGN01.IBG") <> 1) AND (EMI_RECSTATE("VW_ASCII", "IBGN01.IBG") <> -1)) THEN
      EMI_OKAY=FALSE
   ENDIF
   IF ((EMI_RECSTATE("VW_ASCII", "IBGN02.IBG") <> 1) AND (EMI_RECSTATE("VW_ASCII", "IBGN02.IBG") <> -1)) THEN
      EMI_OKAY=FALSE
   ENDIF
   IF ((EMI_RECSTATE("VW_ASCII", "IBGN03.IBG") <> 1) AND (EMI_RECSTATE("VW_ASCII", "IBGN03.IBG") <> -1)) THEN
      EMI_OKAY=FALSE
   ENDIF
   IF ((EMI_RECSTATE("VW_ASCII", "IBGN04.IBG") <> 1) AND (EMI_RECSTATE("VW_ASCII", "IBGN04.IBG") <> -1)) THEN
      EMI_OKAY=FALSE
   ENDIF
   IF ((EMI_RECSTATE("VW_ASCII", "IBGN05.IBG") <> 1) AND (EMI_RECSTATE("VW_ASCII", "IBGN05.IBG") <> -1)) THEN
      EMI_OKAY=FALSE
   ENDIF
   IF ((EMI_RECSTATE("VW_ASCII", "IBGN06.IBG") <> 1) AND (EMI_RECSTATE("VW_ASCII", "IBGN06.IBG") <> -1)) THEN
      EMI_OKAY=FALSE
   ENDIF
   IF ((EMI_RECSTATE("VW_ASCII", "IBGN07.IBG") <> 1) AND (EMI_RECSTATE("VW_ASCII", "IBGN07.IBG") <> -1)) THEN
      EMI_OKAY=FALSE
   ENDIF
   IF ((EMI_RECSTATE("VW_ASCII", "IBGN08.IBG") <> 1) AND (EMI_RECSTATE("VW_ASCII", "IBGN08.IBG") <> -1)) THEN
      EMI_OKAY=FALSE
   ENDIF
   IF ((EMI_RECSTATE("VW_ASCII", "IBGN09.IBG") <> 1) AND (EMI_RECSTATE("VW_ASCII", "IBGN09.IBG") <> -1)) THEN
      EMI_OKAY=FALSE
   ENDIF
   IF ((EMI_RECSTATE("VW_ASCII", "IBGN10.IBG") <> 1) AND (EMI_RECSTATE("VW_ASCII", "IBGN10.IBG") <> -1)) THEN
      EMI_OKAY=FALSE
   ENDIF
   IF ((EMI_RECSTATE("VW_ASCII", "IBGN11.IBG") <> 1) AND (EMI_RECSTATE("VW_ASCII", "IBGN11.IBG") <> -1)) THEN
      EMI_OKAY=FALSE
   ENDIF
   IF ((EMI_RECSTATE("VW_ASCII", "IBGN12.IBG") <> 1) AND (EMI_RECSTATE("VW_ASCII", "IBGN12.IBG") <> -1)) THEN
      EMI_OKAY=FALSE
   ENDIF
   IF ((EMI_RECSTATE("VW_ASCII", "IBGN13.IBG") <> 1) AND (EMI_RECSTATE("VW_ASCII", "IBGN13.IBG") <> -1)) THEN
      EMI_OKAY=FALSE
   ENDIF
   IF ((EMI_RECSTATE("VW_ASCII", "IBGN14.IBG") <> 1) AND (EMI_RECSTATE("VW_ASCII", "IBGN14.IBG") <> -1)) THEN
      EMI_OKAY=FALSE
   ENDIF
   IF ((EMI_RECSTATE("VW_ASCII", "IBGN15.IBG") <> 1) AND (EMI_RECSTATE("VW_ASCII", "IBGN15.IBG") <> -1)) THEN
      EMI_OKAY=FALSE
   ENDIF
  UNTIL ((EMI_OKAY==TRUE)  OR NOT ($LOOP_CONT))
  $LOOP_MSG[]="                                                                                                                                "
  $LOOP_CONT=TRUE
END
GLOBAL DEF MESSAGE_ENDSPLINE()
   LOOP
   MSGNOTIFY("NoEndSplineProgrammed", "VwInlineForms", , , 70)
   HALT
   ENDLOOP
END
GLOBAL DEF MAKRO_CHECK(MAKRORES :IN)
   INT MAKRORES
   IF (MAKRORES == 0) THEN
      LOOP
      MSGNOTIFY("WrongMakro", "VwInlineForms", , , 71)
      BRAKE
      HALT
      ENDLOOP
   ENDIF
END

DEF ANA_ACTIVE_INIT()
   ANA_DEL_AKTIV1=FALSE
   ANA_DEL_AKTIV2=FALSE
   ANA_DEL_AKTIV3=FALSE
   ANA_DEL_AKTIV4=FALSE
   ANA_DEL_AKTIV5=FALSE
   ANA_DEL_AKTIV6=FALSE
   ANA_DEL_AKTIV7=FALSE
   ANA_DEL_AKTIV8=FALSE
   ANA_DEL_AKTIV9=FALSE
   ANA_DEL_AKTIV10=FALSE
   ANA_DEL_AKTIV11=FALSE
   ANA_DEL_AKTIV12=FALSE
   ANA_DEL_AKTIV13=FALSE
   ANA_DEL_AKTIV14=FALSE
   ANA_DEL_AKTIV15=FALSE
   ANA_DEL_AKTIV16=FALSE
END

GLOBAL DEF SET_MSG_DELAY (SUB_NR :IN,COND :IN)
   INT SUB_NR
   BOOL COND
   IF (SUB_NR>0) AND (SUB_NR<6) THEN
      MS_LOOP_CONT[SUB_NR]=TRUE  
   ENDIF   
   IF COND OR (SUB_NR==0) THEN
      $TIMER[63] = -1000
      $TIMER_STOP[63]=FALSE
   ENDIF
END

GLOBAL DEF RESET_MSG_DELAY (SUB_NR :IN,COND :IN)
   INT SUB_NR
   BOOL COND
   IF (SUB_NR>0) AND (SUB_NR<6) THEN
      MS_LOOP_MSG[SUB_NR].LOOP_INFO[]="                                                                                                                                "
   ENDIF
   IF COND OR (SUB_NR==0) THEN
      $TIMER[63] = -10000
      $TIMER_STOP[63]=TRUE
   ENDIF
END

;ENDFOLD