&ACCESS  RV
&COMMENT KS 2.8
&PARAM DISKPATH = VW_User/Applikation/VW_Buersten
&PARAM TPVW_VERSION = 8.3.8
&REL 243
DEF vw_bu_usr_s( )
  ; 
  ;*-----------------------------------------------*
  ;* Technologiepaket VW_BU & ACF                  *
  ;*                                               *
  ;* Markenstandard                                *
  ;* Bearbeiter: B. Mildenberger  PEF-2/E0A        *
  ;*                                               *
  ;* Erstellt am:                                  *
  ;* 2015.11.26 BM                                 *
  ;*                                               *
  ;*-----------------------------------------------*
  ; 
END
;
;FOLD INIT Buersten
GLOBAL DEF BU_INIT( )
  INT i
  ;
;FOLD Version Techpaket
  Tech_Buersten.Name[]="KS24.01.006_161031"
;ENDFOLD
;
;FOLD Vorbesetzung Meldungsausgabe
  FOR i = 1 TO 100
    n_BUS_Handle[i]=-1
    n_BUR_Handle[i]=-1
  ENDFOR
;ENDFOLD
;
;FOLD Init VW_BU-variablen
  ;
  ;Init Ausgaben
  $FLAG[F_MOT_ON[1]]=FALSE
  $FLAG[F_MOT_ON[2]]=FALSE
  bu_rampe_1=750
  bu_rampe_2=750
  IF MIT_VwAcf THEN
    Acf_KraftRampe=0
  ENDIF
  v_d_max[1]=3000
  v_d_max[2]=3000
  v_d_min[1]=3000
  v_d_min[2]=3000
  $COUNT_I[Z_n_bu[1]]=100
  $COUNT_I[Z_n_bu[2]]=100
  $COUNT_I[Z_p_bu[1]]=100
  $COUNT_I[Z_p_bu[2]]=100
  ;
;ENDFOLD VW_BU-variablen
;
END
;ENDFOLD
;
;---------------------------------------------------
;FOLD SAW Buersten 
GLOBAL DEF BU_SAW( )
  INT i
  ;
  ;
END
;ENDFOLD
;
;---------------------------------------------------
;FOLD RESET Buersten 
GLOBAL DEF BU_RESET( )
  INT i
  ;
  ;
END
;ENDFOLD
;
;---------------------------------------------------
;FOLD CANCEL Buersten 
GLOBAL DEF BU_CANCEL( )
  INT i
  ;
  ;
END
;ENDFOLD
;
;---------------------------------------------------
;FOLD LOOP Buersten 
GLOBAL DEF BU_LOOP(AppNummer: IN)
  REAL ana_p, ana_n
  INT AppNummer, AppLauf
  ;
  IF MIT_VwAcf THEN
    ;
    IF MIT_VwBu[1] THEN
      ;Istposition ACF
      ACF_PosAct=ABS(3276.7*$ANIN[I_AN_ACF_actPos])
      ;Ueberwachung Arbeitskontakt ACF
      IF ($OUT[O_R_PFO]==FALSE) AND MIT_AcfRange AND (ACF_PosAct>ACF_RANGE_H) AND (ACF_PosAct<ACF_RANGE_L) THEN
        B_ACF_RANGE=TRUE ; ACF innerhalb Arbeitsbereich
      ELSE
        B_ACF_RANGE=FALSE
      ENDIF  
      IF $FLAG[F_Uebw_Arbpos[1]] THEN
        IF NOT B_ACF_RANGE AND ($MODE_OP==#EX) AND NOT $IN[I_FT_o_BT] THEN
          $FLAG[F_BU_STOER[1]] = TRUE
          $COUNT_I[Z_p_bu[1]] = (-1*100)    
          $FLAG[F_MOT_ON[1]] = FALSE
        ENDIF
      ENDIF
      ;Ueberwachung Fehlercode ACF
      IF (Acf_Stoerung>0) THEN
        $FLAG[F_ACF_IO]=FALSE
        ;
        ;hier Platz fuer Einzelmeldungen
        ;
      ELSE
        $FLAG[F_ACF_IO]=TRUE
      ENDIF
    ENDIF
    ;
  ENDIF
  ;
  IF ($OUT[O_R_PFO]==TRUE) AND $COULD_START_MOTION THEN
    ;Initialdruck für VW_BU langsam auf 99% anheben
    IF (AppNummer==1) AND NOT MIT_VwAcf THEN
      IF ($ANOUT[AO_p_bu[1]] < 0.99) THEN
        AnOut1Hifu = $ANOUT[AO_p_bu[1]] + ((0.99 - $ANOUT[AO_p_bu[1]]) * 0.25)
        $ANOUT[AO_p_bu[1]]=AnOut1Hifu
      ENDIF
    ELSE
      IF ($ANOUT[AO_p_bu[2]] < 0.99) THEN
        AnOut1Hifu = $ANOUT[AO_p_bu[2]] + ((0.99 - $ANOUT[AO_p_bu[2]]) * 0.25)
        $ANOUT[AO_p_bu[2]]=AnOut1Hifu
      ENDIF
    ENDIF
    ;
    ;Init Ausgaben
    $FLAG[F_MOT_ON[1]]=FALSE
    $FLAG[F_MOT_ON[2]]=FALSE
    bu_rampe_1=750
    bu_rampe_2=750
    IF MIT_VwAcf THEN
      Acf_KraftRampe=0
    ENDIF
    v_d_max[1]=3000
    v_d_max[2]=3000
    v_d_min[1]=3000
    v_d_min[2]=3000
    $COUNT_I[Z_n_bu[1]]=100
    $COUNT_I[Z_n_bu[2]]=100
    $COUNT_I[Z_p_bu[1]]=100
    $COUNT_I[Z_p_bu[2]]=100
    ;
  ENDIF
  ;
  FOR AppLauf = 1 TO MaxAppBu
    ;Ueberwachung Arbeitskontakt BU1
    IF MIT_VwBu[AppLauf] AND (NOT MIT_VwAcf OR (AppLauf==2)) AND ($OUT[O_R_PFO]==FALSE) AND (($FLAG[F_Uebw_Arbpos[AppLauf]] AND NOT $IN[I_BU_ArbPos[AppLauf]]) OR $FLAG[F_BU_STOER[AppLauf]]) THEN
      $FLAG[F_BU_STOER[AppLauf]] = TRUE
      $COUNT_I[Z_p_bu[AppLauf]] = 0    
    ENDIF
    
    IF MIT_VwBu[AppLauf] THEN
      
      ;Plausibilitätsprüfungen
      IF ($COUNT_I[Z_UabsMinBu[AppLauf]] < 0) OR ($COUNT_I[Z_UabsMinBu[AppLauf]] > 9999) THEN
        Buersten_Msg(13,#QuitMsg)
        $COUNT_I[Z_UabsMinBu[AppLauf]]=0
        Buersten_Msg(13,#NotifyMsg) ;UabsMin muss größer 0
      ENDIF
      
      ;Ausgaben berechnen BU1
      OutVwBu(AppLauf, dm_akt[AppLauf], $COUNT_I[Z_n_bu[AppLauf]], $COUNT_I[Z_p_bu[AppLauf]], $COUNT_I[Z_UabsMinBu[AppLauf]], ana_p, ana_n)
      ;Ausgabe Druck/Drehzahl
      IF (AppLauf==1) AND MIT_VwAcf THEN	
        $ANOUT[O_AN_ACF_targ]=ana_p*10000/32767
        ACF_Result_3=ana_p*10000; Darstellung config.mon
        C_Pbu=ana_p*1000000
        ACF_Value_1=Acf_IstKraft
        ACF_Value_2=ACF_PosAct
      ENDIF
      IF (AppLauf==2) OR NOT MIT_VwAcf THEN
        $ANOUT[AO_p_bu[AppLauf]] = ana_p * 100; Faktor wird an vProp-Ventil FESTO parametriert
        C_Pbu=$ANOUT[AO_p_bu[AppLauf]] * 10000
        ACF_Result_3=0
        ACF_Value_1=0
        ACF_Value_2=0
      ENDIF
      $ANOUT[AO_n_bu[AppLauf]] = ana_n
      
      ;Freigabe Antrieb BU1  
      $OUT[O_REGLSP_BU[AppLauf]] = NOT $OUT[O_R_PERI_RDY]
      $OUT[O_SCHNSTP_BU[AppLauf]] = $OUT[O_R_PERI_RDY]
	  IF NOT $OUT[O_R_SG_gesp] AND NOT $IN[I_R_k_ZutrA] THEN
	    $OUT[O_BU_EIN[AppLauf]] = FALSE
      ELSE
        $OUT[O_BU_EIN[AppLauf]] = NOT $FLAG[F_BU_STOER[AppLauf]] AND $FLAG[F_MOT_ON[AppLauf]] AND $FLAG[F_FB_PSPS] AND $FLAG[F_OV_100] AND $OUT[O_R_Proz_akt]
      ENDIF
	  $OUT[O_BU_RES[AppLauf]] = $IN[I_RES_BU[AppLauf]]
      
      ;Meldungen an BMS
      $OUT[O_90_WARN[AppLauf]] = $OUT[O_R_Auto] AND NOT F_WARN_AUS[AppLauf] AND $COULD_START_MOTION
      $OUT[O_98_STANDZ[AppLauf]] = $OUT[O_R_Auto] AND NOT $FLAG[F_VER_AUS[AppLauf]] AND $COULD_START_MOTION
      $OUT[O_STOER_MES[AppLauf]] = $OUT[O_R_Auto] AND NOT $FLAG[F_FEHLM_AUS[AppLauf]] AND $COULD_START_MOTION
      $OUT[O_BU_STOER[AppLauf]] = ($OUT[O_R_Auto] AND $FLAG[F_BU_STOER[AppLauf]] OR $IN[I_BU_Stoer[AppLauf]] OR (MIT_VwAcf AND NOT $FLAG[F_ACF_IO])) AND $COULD_START_MOTION
      $OUT[O_STOER_FU[AppLauf]] = $OUT[O_R_Auto] AND $IN[I_BU_Stoer[AppLauf]] AND $COULD_START_MOTION
      $OUT[O_ProzAktBu[AppLauf]] = NOT $OUT[O_MESSAktBu[AppLauf]] AND $FLAG[F_MOT_ON[AppLauf]]	
      
      ;Zyklische Messueberwachung
      IF ($COUNT_I[Z_Zmess_bu[AppLauf]]>0) THEN
        $FLAG[F_ZykMessBu[AppLauf]] = TRUE
      ELSE
        $FLAG[F_ZykMessBu[AppLauf]] = FALSE
      ENDIF	
    ENDIF   
  ENDFOR
  ;
END
;ENDFOLD
;
;---------------------------------------------------
;FOLD P-/N-Regelung
DEF OutVwBu(nr :IN, d_akt: IN, cnt_n :in, cnt_p :IN, UabsMin: IN, ana_p :OUT, ana_n : OUT )
  INT nr, d_akt, cnt_n, cnt_p, UabsMin
  REAL p_out, n_out, ana_p, ana_n, p_anf, frq, stg, dx
  
  IF(dm_min[nr] <> dm_max[nr]) THEN
    ;################################DRUCK
    stg = (u_dmax[nr] - u_dmin[nr])/(dm_max[nr] - dm_min[nr])
    dx = d_akt - dm_min[nr]
    p_out = (u_dmin[nr] + stg*dx)/100*cnt_p 
    ;################################DREHZAHL
    stg = (v_d_max[nr] - v_d_min[nr])/(dm_max[nr] - dm_min[nr])
    dx = d_akt - dm_min[nr] 
    n_out = (v_d_min[nr] + stg*dx)/100*cnt_n 
  ELSE  
    p_out = u_dmax[nr]/100*cnt_p ;Druck ohne Scheibenabnutzung berechnen
    n_out = v_d_max[nr]/100*cnt_n ; Drehzahl ohne Scheibenabnutzung berechnen 
  ENDIF
  
  IF(p_out > 9900.0) THEN
    p_out = 9900.0   ;Druck auf Max. begrenzen
  ENDIF
  
  IF(p_out < UabsMin) THEN
    IF(cnt_p > 0.1) THEN
      p_out = UabsMin  ;Druck auf Min. begrenzen
    ENDIF
  ENDIF
  
  ana_p = p_out/10000.0
  frq = n_out/60    ;frequenz für 2-Polige Mot.
  
  IF(v_nenn[nr] < 1500) THEN
    frq = frq*2
  ELSE
    IF(frq > 75) THEN
      frq = 75
    ENDIF
  ENDIF
  IF(frq > 99.0) THEN
    frq = 99.0
  ENDIF
  
  frq = frq/100.0*0.5    ; 16384 = HEX 4000 ^= 100Hz sew ^= 0.5 Volt ANOUT
  
  ana_n = frq
  
  ;Ausgabe an configmon.ini
  C_BuNr=nr
  C_UserPbu=cnt_p
  C_Nbu=n_out
  C_UserNbu=cnt_n
  C_PabsMin=ABS(UabsMin)
  C_DaktBu=d_akt
  ;
END
;ENDFOLD P-/N-Regelung
;
;---------------------------------------------------
;FOLD BU_Meldungen
DEF Buersten_Msg(msg_nr :IN, MsgTyp :IN)
  INT msg_nr, Answer
  DECL BUS_MsgType MsgTyp
  DECL KrlMsg_T USER_MSG
  DECL KrlMsgPar_T Par[3]
  DECL KrlMsgOpt_T Opt
  ;
  USER_MSG = { Modul[] "BU_S_Msg", Nr -1, Msg_txt[] " "}
  Opt = { VL_Stop FALSE, Clear_P_Reset TRUE, Log_To_DB TRUE }
  Par[1] = { Par_type #Value, Par_txt[] " " }
  ;
  ;
  IF ((n_BUS_Handle[msg_nr]<0) OR (MsgTyp==#NotifyMsg) OR (MsgTyp==#QuitMsg)) THEN
    USER_MSG.Nr = msg_nr
    SWITCH msg_nr
      CASE 11
        USER_MSG.MSG_TXT[]="Druck kleiner 0 mV nicht zulaessig!"
      CASE 12
        USER_MSG.MSG_TXT[]="Druck bei Dmax muss niedriger sein als bei Dmin!"
      CASE 13
        USER_MSG.MSG_TXT[]="Absolut Pmin muss zwischen 0 und 9999 (mV) liegen!"
      DEFAULT
        USER_MSG.MSG_TXT[]="unbekannte Meldung"
    ENDSWITCH
    SWITCH MsgTyp
      CASE #StateMsg
        n_BUS_Handle[msg_nr] = Set_KrlMsg (#State, USER_MSG, Par[], Opt) ;Ausgabe Statusmeldung
      CASE #QuitMsg
        n_BUS_Handle[msg_nr] = Set_KrlMsg (#Quit, USER_MSG, Par[], Opt) ;Ausgabe Quittierungsmeldung
      CASE #NotifyMsg
        n_BUS_Handle[msg_nr] = Set_KrlMsg (#Notify, USER_MSG, Par[], Opt) ;Ausgabe Hinweismeldung
      DEFAULT
        n_BUS_Handle[msg_nr] = Set_KrlMsg (#Quit, USER_MSG, Par[], Opt) ;Ausgabe Quittierungsmeldung
    ENDSWITCH
  ENDIF
END
;
;ENDFOLD (BU Meldungen)