&ACCESS  RV
&PARAM DISKPATH = VW_User/Applikation/Vision/Audi_EKI
&PARAM TPVW_VERSION = 8.3.8
&REL 200
DEF vw_eki_usr_s( )
; 
;*-----------------------------------------------------*
;*Technologiepaket Audi_EKI                            *
;*                                                     *
;*Konzernstandard                                      *
;*Bearbeiter: W. Lehmeier I/PG-C61                     *
;*                                                     *
;* Erstellt am:                                        *
;* 2015.06.17 LE                                       *
;*                                                     *
;*------------------------------------------------------
; 
END
;
;FOLD INIT Audi_EKI
GLOBAL DEF A_EKI_INIT( )
INT i
;
;FOLD Version Techpaket
Tech_AudiEKI.Name[]="KS24.01.001_150617"
;ENDFOLD
;
;FOLD Vorbesetzung Meldungsausgabe
FOR i = 1 TO 100
  n_EKIS_Handle[i]=-1
  n_EKIR_Handle[i]=-1
ENDFOR
;ENDFOLD
;
END
;ENDFOLD
;
;-----------------------------------------------------------
;FOLD SAW Audi_EKI 
GLOBAL DEF A_EKI_SAW( )
INT i
;
AuftragsNr=0
Out_Typ=0
Out_OP_A=0
In_Typ=0
In_OP_A=0
In_Status=0
B_EKI_z_gr=FALSE
B_EKI_k_Ve=FALSE
B_EKI_f_OP=FALSE
B_EKI_f_Ty=FALSE
B_EKI_k_BT=FALSE
B_EKI_T_Ou=FALSE
;
END
;ENDFOLD
;
;-----------------------------------------------------------
;FOLD RESET Audi_EKI 
GLOBAL DEF A_EKI_RESET( )
INT i
;
;
END
;ENDFOLD
;
;-----------------------------------------------------------
;FOLD CANCEL Audi_EKI 
GLOBAL DEF A_EKI_CANCEL( )
INT i
;
;
END
;ENDFOLD
;
;-----------------------------------------------------------
;FOLD LOOP Audi_EKI 
GLOBAL DEF A_EKI_LOOP( )
;
;Ausgabe Fehlermeldungen
;
;Verschiebewerte zu gross
$OUT[O_EKI_z_gr]=$OUT[O_R_Auto] AND $OUT[O_R_RK100] AND B_EKI_z_gr
;keine Verschiebung durchgefuehrt
$OUT[O_EKI_k_Ve]=$OUT[O_R_Auto] AND $OUT[O_R_RK100] AND B_EKI_k_Ve
;falsche OP angewaehlt
$OUT[O_EKI_f_OP]=$OUT[O_R_Auto] AND $OUT[O_R_RK100] AND B_EKI_f_OP
;falscher Typ angewaehlt
$OUT[O_EKI_f_Ty]=$OUT[O_R_Auto] AND $OUT[O_R_RK100] AND B_EKI_f_Ty
;kein Bauteil gefunden
$OUT[O_EKI_k_BT]=$OUT[O_R_Auto] AND $OUT[O_R_RK100] AND B_EKI_k_BT
;TimeOut / Cognex Offline
$OUT[O_EKI_T_Ou]=$OUT[O_R_Auto] AND $OUT[O_R_RK100] AND B_EKI_T_Ou
;Sammelstoerung
$OUT[O_EKI_Samm]=$OUT[O_R_Auto] AND $OUT[O_R_RK100] AND (B_EKI_z_gr OR B_EKI_k_Ve OR B_EKI_f_OP OR B_EKI_f_Ty OR B_EKI_k_BT OR B_EKI_T_Ou)
;
;FOLD Anwenderflag ruecksetzen
IF $OUT[O_R_PFO] AND $ROB_STOPPED AND (($mode_op==#T1) OR ($mode_op==#T2)) THEN
  B_EKI_z_gr=FALSE
  B_EKI_k_Ve=FALSE
  B_EKI_f_OP=FALSE
  B_EKI_f_Ty=FALSE
  B_EKI_k_BT=FALSE
  B_EKI_T_Ou=FALSE
ENDIF  
;
END
;ENDFOLD
;
;-----------------------------------------------------------
;FOLD Lebensbit EKI
DEF L_Bit_EKI(EKINr :IN)
;Setzen / Rueksetzen Lebensbit Roboter
INT EKINr
BOOL LBitEKI, LBitFault
INT RobTimer
BOOL ErrLBit, bRet
ErrLBit = FALSE
LBitFault=FALSE
;Setzen - Rucksetzen  des Lebensbit an Zangensteuerung
$OUT[LBitToEKI[EKINr]] = NOT $IN[LBitFromEKI[EKINr]]
RobTimer = $ROB_TIMER	
IF $IN[LBitFromEKI[EKINr]] <> LBitState[EKINr] THEN
  LBitTimeCnt[EKINr] = RobTimer
ENDIF
IF (RobTimer - LBitTimeCnt[EKINr]) > 5000 THEN
  ErrLBit = TRUE
  ErrEKINr = EKINr
  EKI_LBitFeh[EKINr]=TRUE
ENDIF
LBitState[EKINr] = $IN[LBitFromEKI[EKINr]]
IF ErrLBit THEN
  AudiEKI_Msg(1,#StateMsg, ErrEKINr)
ELSE
  IF n_EKIS_Handle[1]>-1 THEN
    bRet=Clear_KrlMsg(n_EKIS_Handle[1])
    n_EKIS_Handle[1]=-1
    ErrEKINr = -1
  ENDIF
  EKI_LBitFeh[EKINr]=FALSE
ENDIF
END
;ENDFOLD
;
;-----------------------------------------------------------
;FOLD EKI_Meldungen
DEF AudiEKI_Msg(msg_nr :IN, MsgTyp :IN, EKINr :IN)
INT msg_nr, EKINr, Answer
DECL EKIS_MsgType MsgTyp
DECL KrlMsg_T USER_MSG
DECL KrlMsgPar_T Par[3]
DECL KrlMsgOpt_T Opt
;
USER_MSG = { Modul[] "EKI_S_Msg", Nr -1, Msg_txt[] " "}
Opt = { VL_Stop FALSE, Clear_P_Reset TRUE, Log_To_DB TRUE }
Par[1] = { Par_type #Value, Par_txt[] " " }
;
IF Varstate("EKINr")==#initialized then
  SWITCH EKINr
    CASE 1
      Par[1] = { Par_type #Value, Par_int 1 }
    CASE 2
      Par[1] = { Par_type #Value, Par_int 2 }
    CASE 3
      Par[1] = { Par_type #Value, Par_int 3 }
    CASE 4
      Par[1] = { Par_type #Value, Par_int 4 }
    CASE 5
      Par[1] = { Par_type #Value, Par_int 5 }
    CASE 6
      Par[1] = { Par_type #Value, Par_int 6 }
    DEFAULT
      Par[1] = { Par_type #Value, Par_txt[] " " }
  ENDSWITCH
ELSE
  Par[1] = { Par_type #Value, Par_txt[] " " }
ENDIF
;
IF ((n_EKIS_Handle[msg_nr]<0) OR (MsgTyp==#NotifyMsg) OR (MsgTyp==#QuitMsg)) THEN
  USER_MSG.Nr = msg_nr
  SWITCH msg_nr
    CASE 1
	   USER_MSG.MSG_TXT[]="EKI%1 :keine Antwort auf Lebensbit"
    CASE 2
	   USER_MSG.MSG_TXT[]=" "
    CASE 3
	   USER_MSG.MSG_TXT[]=" "
    CASE 4
	   USER_MSG.MSG_TXT[]=" "
    DEFAULT
	   USER_MSG.MSG_TXT[]="unbekannte Meldung"
  ENDSWITCH
  SWITCH MsgTyp
    CASE #StateMsg
      n_EKIS_Handle[msg_nr] = Set_KrlMsg (#State, USER_MSG, Par[], Opt) ;Ausgabe Statusmeldung
    CASE #QuitMsg
      n_EKIS_Handle[msg_nr] = Set_KrlMsg (#Quit, USER_MSG, Par[], Opt) ;Ausgabe Quittierungsmeldung
    CASE #NotifyMsg
      n_EKIS_Handle[msg_nr] = Set_KrlMsg (#Notify, USER_MSG, Par[], Opt) ;Ausgabe Hinweismeldung
    DEFAULT
      n_EKIS_Handle[msg_nr] = Set_KrlMsg (#Quit, USER_MSG, Par[], Opt) ;Ausgabe Quittierungsmeldung
  ENDSWITCH
ENDIF
END
;
;ENDFOLD (EKI Meldungen)
