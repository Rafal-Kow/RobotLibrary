&ACCESS  RV
&COMMENT KS_1.0
&PARAM DISKPATH = VW_User/Applikation/Blindnietmuttern
&PARAM TPVW_VERSION = 8.3.8
&REL 11
DEF vw_bn_usr_s( )
;FOLD Aenderungsjournal 
;*-------------------------------------------------*
;*Technologiepaket Blindnietmuttern                *
;*                                                 *
;*Konzernstandard                                  *
;*Bearbeiter: B.Mildenberger PEF-2/E0A             *
;*                                                 *
;* Erstellt am:                                    *
;* 2016.02.19 BM                                   *
;*                                                 *
;* Aenderungsjournal                               *
;*                                                 *
;*-------------------------------------------------*
;ENDFOLD Aenderungsjournal 
END
;
;FOLD INIT Blindnietmuttern
GLOBAL DEF BN_INIT( )
INT i
;
;FOLD Version Techpaket
Tech_BN.Name[]="KS24.01.002_160220"
;ENDFOLD
;
;FOLD Vorbesetzung Meldungsausgabe
FOR I = 1 TO 100
  n_BN_Handle[I]=-1
ENDFOR
;ENDFOLD
;
$OUT[O_BN_StartPrz[1]]=FALSE
;
END
;ENDFOLD
;
;---------------------------------------------------
;FOLD SAW Blindnietmuttern
GLOBAL DEF BN_SAW( )
INT i
;
;
END
;ENDFOLD
;
;---------------------------------------------------
;FOLD RESET Blindnietmuttern
GLOBAL DEF BN_RESET( )
INT i
;
$OUT[O_BN_StartPrz[1]]=FALSE
;
END
;ENDFOLD
;
;---------------------------------------------------
;FOLD CANCEL Blindnietmuttern
GLOBAL DEF BN_CANCEL( )
INT i
;
$OUT[O_BN_StartPrz[1]]=FALSE
;
END
;ENDFOLD
;
;---------------------------------------------------
;FOLD LOOP Blindnietmuttern
GLOBAL DEF BN_LOOP()
;
FOR BN_ActApp = 1 TO BN_MaxApp
  IF Mit_BN[BN_ActApp] THEN
    ;FOLD Lebensbit
    BN_lBit(BN_ActApp)
    ;ENDFOLD Lebensbit
;
    ;RESET im Fehlerfall ausloesen
    IF NOT BN_QuitHifu[BN_ActApp] AND (NOT $OUT[O_R_SAK] OR NOT $OUT[O_R_RK100]) THEN
      BN_QuitHifu[BN_ActApp]=TRUE
      ;Anstehende Prozesse sicher beenden
      $OUT[O_BN_Reload[BN_ActApp]]=FALSE
      $OUT[O_BN_StartPrz[BN_ActApp]]=FALSE
    ENDIF
    SWITCH BN1_ErrorCode ;Gezieltes Quittieren selektierter Fehler 
	  CASE 107, 108
	    BN_FrgQuitHifu[BN_ActApp]=FALSE;keine Freigabe Autoquit
	  DEFAULT
        BN_FrgQuitHifu[BN_ActApp]=TRUE
	ENDSWITCH 
    ;Ruecksetzen Ausgaben nach Fehler
    IF $OUT[O_R_RK100] AND $OUT[O_R_SAK] AND BN_QuitHifu[BN_ActApp] AND BN_FrgQuitHifu[BN_ActApp] AND $COULD_START_MOTION THEN
      $OUT[O_BN_Reset[BN_ActApp]]=TRUE
	  IF (($ROB_TIMER - QuitTimer_BN[BN_ActApp]) > 500) THEN
	    $OUT[O_BN_Init[BN_ActApp]]=TRUE
	    $OUT[O_BN_Reset[BN_ActApp]]=FALSE
		IF $OUT[O_BN_Init[BN_ActApp]] AND $IN[I_BN_FkInit[BN_ActApp]] THEN
  	      $OUT[O_BN_Init[BN_ActApp]]=FALSE
		  BN_QuitHifu[BN_ActApp]=FALSE
	    ELSE
        IF (($ROB_TIMER - QuitTimer_BN[BN_ActApp]) > 5000) AND $IN[I_BN_AUTO[BN_ActApp]] THEN
		    BN_Msg(2,#QuitMsg)
			;Retry Init
			$OUT[O_BN_Reset[BN_ActApp]]=TRUE
			QuitTimer_BN[BN_ActApp] = 0
            QuitTimer_BN[BN_ActApp] = $ROB_TIMER	
		  ENDIF
		ENDIF
	  ENDIF
	ELSE
      QuitTimer_BN[BN_ActApp] = 0
      QuitTimer_BN[BN_ActApp] = $ROB_TIMER	
    ENDIF	
;
    ;BA-Hand an BNx setzen
    IF $OUT[O_R_Hand] AND NOT $COULD_START_MOTION THEN
      $OUT[O_BN_R_Hand[BN_ActApp]]=TRUE
      $OUT[O_BN_R_Auto[BN_ActApp]]=FALSE
    ENDIF
;
    ;BA-AUTO an NZ 1 setzen
    IF ($OUT[O_R_Proz_akt] OR $OUT[O_R_bewegt]) OR $OUT[O_R_Auto] THEN
      $OUT[O_BN_R_Hand[BN_ActApp]]=FALSE
      $OUT[O_BN_R_Auto[BN_ActApp]]=TRUE
    ENDIF
;
    ;Anwahl Energiesparmodus
    $OUT[O_BN_eMode[BN_ActApp]] = (($Brake_Sig==0) AND $timer_flag[TimerNr_E_Mo] AND e_Mode_Hilf2)    
    ;Freigabe Steuerluft
    $OUT[O_BN_FrgP[BN_ActApp]] = $IN[I_BD01ND] AND $IN[I_MedVorh] 
;
    ;Setzweg fuer Visualisierung in CorrMode
	BN_Setzweg_Act[BN_ActApp]=ABS(BN1_SetzWeg)/10 ;[1/10mm]
;
    ;Ausgabe Fehlermeldungen
;	
    ;Nieten n.i.O.
    $OUT[O_BN_PrzNio[BN_ActApp]]=$OUT[O_R_Auto] AND $COULD_START_MOTION AND $OUT[O_BN_P_act[BN_ActApp]] AND $FLAG[F_BN_PrzNiO[BN_ActApp]]
    ;Vorwarnung liegt an
    $OUT[O_BN_VwStdm[BN_ActApp]]=$OUT[O_R_Auto] AND $COULD_START_MOTION AND ($IN[I_BN_WarnZugDorn[BN_ActApp]] OR $IN[I_BN_WarnOel[BN_ActApp]])
    ;Verklemmanzeige
    $OUT[O_BN_Verkl[BN_ActApp]]=$OUT[O_R_Auto] AND $COULD_START_MOTION AND NOT $IN[I_BN_AusglIo[BN_ActApp]]
    ;Startbereit fehlt
    $OUT[O_BN_StartBerFehl[BN_ActApp]]=$OUT[O_R_Auto] AND $COULD_START_MOTION AND NOT $IN[I_BN_Ready[BN_ActApp]] AND $FLAG[F_BN_Sammel[BN_ActApp]] AND $timer_flag[TimerNr_Ein]
    ;Betriebsbereit fehlt
    $OUT[O_BN_BereitFehlt[BN_ActApp]]=$OUT[O_R_Auto] AND $COULD_START_MOTION AND NOT $IN[I_BN_Ready[BN_ActApp]] AND $timer_flag[TimerNr_Ein]
    ;Sammelstoerung
    $OUT[O_BN_Sammel[BN_ActApp]]=$OUT[O_R_Auto] AND $COULD_START_MOTION AND ($FLAG[F_BN_Sammel[BN_ActApp]] OR $IN[I_BN_Sammel[BN_ActApp]] OR BN_LBitFeh[BN_ActApp] OR $IN[I_BN_StdmZugDorn[BN_ActApp]]) AND $timer_flag[TimerNr_Ein]
    ;Stoerung quittieren
	IF (BN_ActApp==1) THEN
 	  BN_ErrorCodeAct[1]=BN1_ErrorCode
	ENDIF
	SWITCH BN1_ErrorCode ;Vorhaltung zur gezielten Reaktion auf bestimmte Fehleransprachen
	  CASE 0
	    ;l√∂ppt
	  CASE 108 ; Fehler Zugdorn darf nicht via Panel quittiert werden
	    ;#dummy
	  DEFAULT
        $OUT[O_BN_Reset[BN_ActApp]]= $IN[I_BN_Sammel[BN_ActApp]] AND $IN[I_BN_AnwZ1[BN_ActApp]] AND $IN[I_R_Quit_Wei] 
	ENDSWITCH
;
    ;Ausgabe Zangencode
    IF NOT Docking THEN
      BN1_ZCode=1
    ENDIF    
;
  ENDIF
ENDFOR
;
;ENDFOLD
END
;ENDFOLD
;
;---------------------------------------------------
;---------------------------------------------------
;FOLD Blindnietmuttern_Meldungen
DEF BN_Msg(msg_nr :IN, MsgTyp :IN)
INT msg_nr, Answer
DECL BN_MsgType MsgTyp
DECL KrlMsg_T USER_MSG
DECL KrlMsgPar_T Par[3]
DECL KrlMsgOpt_T Opt
;
USER_MSG = { Modul[] "BN_S_Msg", Nr -1, Msg_txt[] " "}
Opt = { VL_Stop FALSE, Clear_P_Reset TRUE, Log_To_DB TRUE }
Par[1] = { Par_type #Value, Par_txt[] " " }
;
;
IF ((n_BN_Handle[msg_nr]<0) OR (MsgTyp==#NotifyMsg) OR (MsgTyp==#QuitMsg)) THEN
  USER_MSG.Nr = msg_nr
  SWITCH msg_nr
    CASE 1
	   USER_MSG.MSG_TXT[]="Blindnietmutternsteuerung Lebensbitfehler"
    CASE 2
	   USER_MSG.MSG_TXT[]="Initialisierungsfehler Blindnietmutternsteuerung"
    DEFAULT
	   USER_MSG.MSG_TXT[]="unbekannte Meldung"
  ENDSWITCH
  SWITCH MsgTyp
    CASE #StateMsg
      n_BN_Handle[msg_nr] = Set_KrlMsg (#State, USER_MSG, Par[], Opt) ;Ausgabe Statusmeldung
    CASE #QuitMsg
      n_BN_Handle[msg_nr] = Set_KrlMsg (#Quit, USER_MSG, Par[], Opt) ;Ausgabe Quittierungsmeldung
    CASE #NotifyMsg
      n_BN_Handle[msg_nr] = Set_KrlMsg (#Notify, USER_MSG, Par[], Opt) ;Ausgabe Hinweismeldung
    DEFAULT
      n_BN_Handle[msg_nr] = Set_KrlMsg (#Quit, USER_MSG, Par[], Opt) ;Ausgabe Quittierungsmeldung
  ENDSWITCH
ENDIF
END
;
;ENDFOLD (Blindnietmuttern Meldungen)
;
;---------------------------------------------------
;FOLD Lebensbit Blindnietmuttern
DEF BN_lBit(AppNr:IN)
BOOL LBitBZ1, bRet
INT AppNr

BN_LBitFeh[AppNr]=FALSE
;Setzen - Rucksetzen Lebensbit Roboter
$OUT[O_BN_LBitRobBn[AppNr]]=NOT $IN[I_BN_LBitBnRob[AppNr]]
;Pruefen Lebensbit von BZ1
IF $IN[I_BN_LBitBnRob[AppNr]]==FALSE THEN
  IF LBitBnRem[AppNr]==FALSE THEN
    TimerNr_BN[AppNr]=$ROB_TIMER
  ENDIF  
  LBitBnRem[AppNr]=TRUE
ELSE
  IF LBitBnRem[AppNr]==TRUE THEN
    TimerNr_BN[AppNr]=$ROB_TIMER
  ENDIF  
  LBitBnRem[AppNr]=FALSE
ENDIF
;
IF ($ROB_TIMER - TimerNr_BN[AppNr]) > 5000 THEN
  BN_LBitFeh[AppNr]=TRUE
ENDIF
;
IF BN_LBitFeh[AppNr] THEN
  BN_Msg(1,#StateMsg)
ELSE
  BN_LBitFeh[AppNr]=FALSE
ENDIF
END
;ENDFOLD Lebensbit Blindnietmuttern
;